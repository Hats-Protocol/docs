# Hats Protocol Documentation

-------------------

# ðŸ‘· Hats Protocol Overview

Put on your hardhats and lets get into the nitty gritty of Hats Protocol!

## What are Hats?

**Hats are roles**. In Hats Protocol, roles are rich, substantive, objectives with multiple dimensions:

* Responsibility
* Authorities/Rights/Powers
* Accountability
* Clarity & context
* Compensation & incentives

These roles, modeled as hats, are embodied onchain in Hats.sol storage, and represented as non-transferable [ERC1155-similar] tokens.

Every hat is connected to at least one other hat in a structure that we call a Hats tree.

The bulk of the protocol logic is devoted to defining how hats are created, issued, revoked, and managed. It also creates several integration points and hooks for developers to extend and customize the behavior of particular hats.

# Hat Properties

Every hat has several properties:

* `id` - the integer identifier for the hat, which also serves as the [ERC1155-similar] token id
* `details` - arbitrary metadata about the hat; such as a name, description, and other properties like roles and responsibilities associated with the hat. Should not exceed 7,000 characters.
* `maxSupply` - the maximum number of addresses that can wear the Hat at once
* `admin` - the hat that can issue the hat to wearers and can its hat's other properties
* `eligibility` - the address that controls eligibility criteria and whether a given wearer of the hat is in good standing
* `toggle` - the address that controls whether the hat is active
* `mutable` - whether the hat's properties can be changed by its admin
* `imageURI` - the URI for the image used in the Hat's ERC1155-similar token. Should not exceed 7,000 characters.

# Wearing a Hat

An account's status relating to a given hat is determined by three factors. If all three are true, then the account is wearing the hat.

1. Whether their address has a balance of the Hat's token â€” we refer to this as the "static" balance
2. Whether the Hat is active (see the Toggle section for more detail)
3. Whether they are eligible (see the Eligibility section for more detail)

Wearing a hat is a binary state. If all three of the above factors are true for a given account, then that account has a balance of 1 of that hat's id. If not, its balance is 0. It is not possible for any account to have a balance greater than 1 for any hat.

Hats Protocol has an `isWearerOfHat()` convenience function that wraps `balanceOf()` and returns a bool for `balance == 1`.

## Dynamic hat balances

In Hats Protocol, the `balanceOf()` function does not simply reflect static contract storage â€” i.e., (1) from the above section. In addition, it reads (via a `staticcall`) dynamically from the hat's Eligibility and Toggle modules â€” (2) and (3) from above â€” and combines the three factors to arrive at the answer of whether a given address has a balance.

This design ensures that there is never a lame duck period between when a wearer's hat is revoked and when they actually lose the onchain authorities associated with the hat.

However, since hat balances may change without an event â€” e.g., if the hat status flips from active to inactive based on an expiration-driven Toggle module â€” apps relying on indexed events may not be reading the source of truth.

In such cases, there are two solutions:

1. Read directly from the contract â€” i.e., `isWearerOfHat()`
2. Trigger a contract state change by calling `checkHatWearerStatus()` and/or `checkHatStatus()`

## Who can wear a hat?

Any account can wear a hat, including:

* Externally Owned Accounts (EOAs)
* Logic contracts (i.e., contracts with explicit logic codified within functions), or
* Governance contracts (e.g., DAOs, multisigs, etc.)

Some of the most power applications of Hats Protocol are made possible by smart contracts wearing hats to automate or minimize trust required for certain logic.

# Hat Admins & Hatter Contracts

The admin of every hat is another hat. This means that the authority to perform admin functions for a given hat is assigned to the wearer of its admin hat.

The scope of authority for a hat's admin is to determine who can wear it. This is reflected in the ability to create the hat and to mint or (for mutable hats) transfer the hat's token.

## Transitive Admin Powers

In Hats Protocol v1, admin powers are transitive. All of a hat's ancestors â€” its direct admin, its admin's admin, etc â€” can serve as its admin.

### Separation of Powers over Hats

In most contexts, an "admin" role has broad, generalized control over the entity it administers. Hats Protocol is different. The generalized control over a given hat is separated into three distinct roles:

| Role | Powers |
| ---- | ------ |
| Admin | - Create new hat<br>- Issue hat to wearer(s), aka "mint"<br>- Edit hat properties (while mutable)<br>- Transfer hat (while mutable) |
| Eligibility Module | - Prevent ineligible addresses from wearing hat<br>- Revoke hat from specific wearer(s) |
| Toggle Module | - Activate / de-active hat â‡’ all wearers lose the hat |

## **Hatter Contracts**

Logic contracts that serve as admins are informally known as "hatter" contracts. These are contracts that implement specific logic or rules. The admin of a hatter contract is the true admin, but has delegated said admin authority to the logic embedded in the hatter.

Hatter contract logic is a wide design space for DAOs. Here are some examples of hatter logic:

| Type | Description |
| ---- | ----------- |
| **Hat creation** | Allow certain addresses -- such as members of a DAO -- to create hats that are then admin'd by the DAO. |
| **Hat minting** | Allow certain addresses -- such as members of a DAO -- to mint hat tokens. Together with the above, a DAO could in this way enable its members to create and wear a certain type of hat permissionlessly. This would be especially if using hats to facilitate role clarity and legibility. |
| **Wearer eligibility** | Enforce certain requirements that prospective wearers must meet in order to wear a given hat, such as membership in a DAO or holding some token(s). *Note that this is often more effectively implemented as an eligibility module.* |
| **Wearer staking** | One particularly important type of eligibility requirement is staking tokens, DAO shares, or some other asset as a bond that could be slashed if the wearer is not a good steward of the accountabilities associated with the hat, or does not follow through on its associated responsibilities. *Note that this is often more effectively implemented as an eligibility module.* |

# Hats Trees

The fact that all hat's have hats as admins means that every hat exist within a "tree" of hats. This tree structure forms the basis for an organization's hats

Within a given branch of a hat tree, hats closer to the root of the tree have admin authorities for hats further down the branch. This is consistent with the direction of delegation of authority for DAOs, and combats the tendency for accountability to dilute as delegated authorities reach the edges of a network.

## **Top Hats**

Top Hats are the one exception to the rule that a hat's admin must be another hat. A Top Hat is a hat that serves as its own admin.

The root of a Hat tree is always a Top Hat. Typically, a DAO will wear the Top Hat that serves as admin for the tree of Hats related to the DAO's operations.

## Hat Trees and Hat Ids

Each hat tree has a max depth of 15 and a branching factor of 2^16. This means that each hat can have up to 2^16 = 65,536 children, and this pattern can repeat 14 times.

Every hat's id includes the id of its tree and its location within the tree. See the following page for more detail on hat ids.

# Hat IDs

Hat ids are semantic. They have meaning.

Hat ids uint256 bitmaps that create an "address" â€” more like an web or IP address than an Ethereum address â€” that includes information about where in the tree a hat is located, including its entire branch of admins.

The 32 bytes of a hat's id are structured as follows:

* The first 4 bytes are reserved for the top hat id. Since top hat ids are unique across a given deployment of Hats Protocol, we can also think of them as the top level "domain" for a hat tree.
* Each of the next chunks of 16 bits refers to a single "Hat Level".

There are 15 total hat levels, beginning with the top hat at level 0 and going up to level 14.

## Example

Consider the following hat id (in hex): 0x0000000f00020005000a00010000000000000000000000000000000000000000

For convenience, we can reformat it into shorthand, just like an IP address: 15.2.5.10.1

From the id alone, we know a lot about this hat:

* It is in hat tree 15
* It is a level 4 hat
* Its immediate admin (aka parent) is 15.2.5.10
* Its grandparent is 15.2.5

## Other hat id formats

| Format | Example |
| ------ | ------- |
| Integer ("raw") | 6470400364654781217010529864562902351218663490360806944392503307010048 |
| Hexadecimal | 0x0000000f000200050000a00010000000000000000000000000000000000000000 |
| Hexadecimal with level delimiters | 0x0000000f.0002.0005.000a.0001.0000.0000.0000.0000.0000.0000.0000.0000.0000.0000<br><br>0x0000000f_0002_0005_000a_0001_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000 |
| "IP address" | 15.2.5.10.1 |

## **Hat Tree Space**

A hat tree can have up to 14 levels, plus the top hat (tree root). Within those 14 levels are 224 bits of address space (remember, one level contains 16 bits of space), so the maximum number of hats in a single hat tree is approximately:

2^224 + 1 â‰ˆ ~2.696 * 10^67

which is well beyond the number of stars in the universe.

# Linking Hats Trees

Not all Hats trees will unfurl from top down or inside out. Sometimes, new branches will form independently from the main tree, or multiple trees will form before a main tree even exists.

In these cases, Hats trees can be grafted onto other trees. This is done via a request-approve process where the wearer of one tree's Top Hat requests to link their Top Hat to a hat in another tree, whose admin can approve if desired. This has three main effects:

1. The linked Top Hat loses its Top Hat status (i.e., `Hats.isTopHat` will return `false`) and turns into what we call a "tree root" or "linked Top Hat", and
2. The hat to which it is linked becomes its new admin; it is no longer its own admin
3. On linking, the linked Top Hat can be assigned eligibility and/or toggle modules like any other hat

Linked hat trees can also be unlinked by the tree root from its linked admin, via `Hats.unlinkTopHatFromTree`. This causes the tree root to regain its status as a top hat and to once again become its own admin. Any eligibility or toggle modules added on linking are cleared. Note that unlinking is only allowed if the tree root is active and has an eligible wearer.

**CAUTION**: Be careful when nesting multiple Hat trees. If the nested linkages become too long, the higher level admins may lose control of the lowest level hats because admin actions at that distance may cost-prohibitive or even exceed the gas limit. Best practice is to not attach external authorities (e.g. via token gating) to hats in trees that are more than ~10 nested trees deep (varies by network).

### **Relinking**

A linked Top Hat can be relinked to a different hat within the same tree. This is useful for groups that want to reorganize their subtrees without having to go through the request and approve steps. Valid relinks must meet the following criteria in order to ensure security:

1. The hat wearer executing the relink is an admin of both the linked topHat and the new admin (destination)
2. The new admin (destination) is within the same local tree as the existing admin (origin), or within the Tippy Top Hat's local tree. Tippy Top Hats executing a relink are not subject to these restrictions.
3. The new link does not create a circular linkage.

# Eligibility Modules

Eligibility modules have authority to rule on the a) eligibility b) good standing of wearer(s) of a given hat.

## Wearer Eligibility

Wearer Eligibility (A) determines whether a given address is eligible to wear the hat. This applies both before and while the address wears the hat. Consider the following scenarios for a given address:

|                             | Eligible                         | Not Eligible                        |
| --------------------------- | -------------------------------- | ----------------------------------- |
| **Doesn't wear the Hat**    | Hat can be minted to the address | Hat cannot be minted to the address |
| **Currently wears the Hat** | Keeps wearing the hat            | The hat is revoked                  |

When a hat is revoked, its token is burned.

## Wearer Standing

Wearer Standing (B) determines whether a given address is in good or bad standing. Standing is stored on-chain in `Hats.sol` to facilitate accountability.

For example, a hatter contract implementing staking logic could slash a wearer's stake if they are placed in bad standing by the eligibility module.

An address placed in bad standing by a hat's eligibility module automatically loses eligibility for that hat. Note, though, that ineligibility does necessarily imply bad standing; it is possible for an address may be ineligible but in good standing.

Any address can serve as an eligibility module for a given hat. Hats Protocol supports two categories of eligibility modules:

1. **Mechanistic eligibility** are logic contracts that implement the `IHatsEligibility` interface, which enables the Hats.sol contract to _pull_ wearer standing by calling `checkWearerStanding` from within the `Hats.balanceOf` function. Mechanistic eligibility enables instantaneous revocation based on pre-defined triggers.
2. **Humanistic eligibility** are either EOAs or governance contracts. To revoke a Hat, humanistic eligibility must _push_ updates to the Hats contract by calling `Hats.ruleOHatWearerStanding`.

Unlike admins, eligibility modules are explicitly set as addresses, not hats. This is to avoid long, potentially illegible, chains of revocation authority that can affect wearer penalties (such as slashed stake).

Eligibility modules offer a large design space for developers to extend and customize organizational infrastructure. See Building Hats Modules for more information.

# Toggle Modules

Toggle contracts have authority to switch the `hat.active` status of a hat, such as from `active` to `inactive`. When a hat is inactive, it does not have any wearers (i.e., the balance of its previous wearers' is changed to 0).

Any address can serve as a hat's toggle. As with eligibility modules, Hats Protocol supports two categories of toggle modules:

1. **Mechanistic toggles** are logic contracts that implement the `IHatsToggle` interface, which enables the hats contract to _pull_ a hat's active status by calling `checkToggle` from within the `Hats.balanceOf` function. Mechanistic toggle enable instantaneous deactivation (or reactivation) based on pre-defined logic, such as timestamps ("this hat expires at the end of the year").
2. **Humanistic toggles** are either EOAs or governance contracts. To deactivate (or reactivate) a hat, humanistic toggles must _push_ updates to the Hats contract by calling `Hats.toggleHatStatus`.

Unlike admins â€” and like eligibility modules, toggle modules are explicitly set as addresses, not Hats.

Toggle modules offer a large design space for developers to extend and customize organizational infrastructure. See Building Hats Modules for more information.

# Hat Mutability and Editing

In some cases, a hat's properties should be immutable to give everybody (particularly the wearer(s)) maximal confidence in what they are signing up for. But this certainty comes at the expense of flexibility, which is often valuable for DAOs as they evolve and learn more about what their various roles are all about. With this trade-off in mind, Hats can be created as either mutable or immutable.

An **immutable** hat cannot be changed at all once it has been created. A **mutable** hat can be changed after it has been created. Only its admin(s) can make the change.

Changes are allowed to the following Hat properties:

* `details`
* `maxSupply` - as long as the new maxSupply is not less than the current supply
* `eligibility`
* `toggle`
* `mutable` - this is a one-way change
* `imageURI`

Additionally, mutable hats can be transferred by their admins to a different wearer. Immutable hats cannot be transferred.

## **Top Hat Exception**

The only exception to the above mutability rules is for Top Hats, which despite being immutable are allowed to change their own `details` and `imageURI` (but not other properties).

Note that this only includes non-linked Top Hats; a Top Hat that has been linked (aka grafted) onto another hat tree is no longer considered a Top Hat, and therefore is subject to the same mutability rules as other hats.

# Creating Hats

The creator of a hat must be its admin. In other words, the admin of a hat must be the `msg.sender` of the `Hats.createHat` function call. Though remember, by delegating its authority to a hatter contract, an admin can enable eligible others to create Hats based on whatever logic it desires.

Creating a Top Hat (a hat that serves as its own admin) requires a special function `mintTophat`, which creates a new hat, sets that hat as its own admin, and then mints its token to a `_target`. Any address wanting to create a hat that is not already wearing an admin hat of some kind must first create a Top Hat with itself as the wearer.

## **Batch Creation**

In some scenarios, a DAO may want to create many hats at once -- including an entire hat tree -- at once. This is particularly useful when setting up an initial structure for a DAO or working group (e.g., from a hats template) or when forking an existing Hats structure from a template.

Enabling this latter forking/exit scenario is an important protection for hat wearers against potential abuse of power by their DAO.

To create a batch of hats, a DAO can call the `Hats.batchCreateHats()` function. This function takes arrays as its arguments, from which it constructs multiple hats. As long as each of these hats is part of the same tree of hats â€” i.e., they either have the same existing Hat or any of the newly created hats as admin(s) â€” they can all be created together.

# Minting Hats

Only a hat's admin(s) can mint its token to a wearer.

To mint a hat:

1. The hat must be active
2. Its max supply must not have already been reached
3. The target wearer must not already wear the hat, and
4. If the hat's eligibility module is mechanistic, the target wearer must be eligible for the hat

A hat's admin can mint its token individually by calling `Hats.mintHat`.

## **Batch Minting**

An admin can also mint multiple hats by calling `Hats.batchMintHats`. This enables an admin to mint instances of the same hat to multiple wearers, to mint several hats at once, or even to mint an entire hats tree it just created.

# Transferring Hats

Only a hat's admin can transfer its token(s) to new wearer(s).

Unlike typical tokens, the wearer of a hat cannot transfer the hat to another wallet. This is because the authorities and responsibilities associated with a hat are delegated to, not owned by, the wearer.

As a result, there is no need for safe transfers (transfers which check whether the recipient supports ERC1155) or to pass data to recipient `on1155Received` or `onERC1155BatchReceived` hooks.

For these reasons, in Hats Protocol, the standard ERC1155 transfer functions â€” `safeTransferFrom` and `safeBatchTransferFrom` are disabled and will always revert. Similarly, token approvals are not required and `setApprovalForAll` will always revert. See more about Hats Protocol and ERC1155 Compatibility here.

As a replacement, hats can be transferred by admins via `Hats.transferHat`, which emits the ERC1155 standard event `TransferSingle`. Transfer recipients must not already be wearing the hat, and must be eligible to wear the hat.

With the exception of Top Hats â€” which can always transfer themselves â€” only mutable and active hats can be transferred.

# Renouncing Hats

The wearer of a hat can "take off" their hat via `Hats.renounceHat`. This burns the token and revokes any associated authorities and responsibilities from the now-former wearer, but does not put the wearer in bad standing.

# Batch Actions

In addition to batch create and batch mint, any set of Hats.sol functions can be batched together into a single transaction.

This is made possible by Multicallable â€” from which Hats.sol inherits â€” which adds a non-payable `multicall` function to the contract. This enables EOAs to make multiple calls to the contract atomically, unlocking a number of useful batch operations that were previously only available to smart contracts.

For example, a DAO can batch together multiple hat creations, mintings, and transfers into a single transaction.

# Hat Image URIs

Like any other NFT, hats have images. The image for a given hat is determined by the following logic:

1. If the hat's `imageURI` property is set, use that
2. If the hat's `imageURI` property is _not_ set, then use the `imageURI` of the hat's admin Hat
3. If the admin hat's `imageURI` property is _not_ set, then use the `imageURI` of _that_ hat's admin
4. Repeat (3) until you find an `imageURI` that is set
5. If no set `imageURI` is found within the original hat's hat tree (including the Top Hat), then use the `globalImageURI` set in the Hats Protocol contract

This logic creates flexibility for DAOs to efficiently customize images for their hats, while keeping images as optional and hat creation relatively cheap.

# ERC1155 Compatibility

Hats Protocol conforms fully to the ERC1155 interface. All external functions required by the [ERC1155 standard] are exposed by Hats Protocol. This is how hats can work out of the box with existing token-gating applications.

However, Hats Protocol is not fully compliant with the ERC1155 standard. Since hats are not transferable by their owners (aka "wearers"), there is little need for safe transfers and the `ERC1155TokenReceiver` logic.

Developers building on top of Hats Protocol should note that mints and transfers of hats will not, for example, include calls to `onERC1155Received`.

To avoid confusion, Hats Protocol does not claim to be ERC1155-_compliant_. Instead, we say that Hats Protocol has "ERC1155-_similar_" tokens. When referring specifically to the ERC1155 _interface_, however, we do say that Hats Protocol conforms fully.

# â›“ï¸ Hats Protocol Supported Chains

Hats Protocol has the same contract address for each chain is it deployed to (ENS: v1.hatsprotocol.eth): `0x3bc1A0Ad72417f2d411118085256fC53CBdDd137`

See below for links to the specific contracts for each chain Hats Protocol is currently on:

* [**Ethereum (mainnet)**](https://etherscan.io/address/0x3bc1A0Ad72417f2d411118085256fC53CBdDd137)
* [**Arbitrum**](https://arbiscan.io/address/0x3bc1A0Ad72417f2d411118085256fC53CBdDd137)
* [**Gnosis Chain**](https://gnosisscan.io/address/0x3bc1A0Ad72417f2d411118085256fC53CBdDd137)
* [**Optimism**](https://optimistic.etherscan.io/address/0x3bc1A0Ad72417f2d411118085256fC53CBdDd137)
* [**Polygon**](https://polygonscan.com/address/0x3bc1A0Ad72417f2d411118085256fC53CBdDd137)
* [**Scroll**](https://scrollscan.com/address/0x3bc1a0ad72417f2d411118085256fc53cbddd137)
* [**Celo**](https://celoscan.io/address/0x3bc1A0Ad72417f2d411118085256fC53CBdDd137)
* [**Base**](https://basescan.org/address/0x3bc1A0Ad72417f2d411118085256fC53CBdDd137)
* [**Sepolia (testnet)**](https://sepolia.etherscan.io/address/0x3bc1A0Ad72417f2d411118085256fC53CBdDd137)
* [**Holesky (testnet)**](https://holesky.etherscan.io/address/0x3bc1A0Ad72417f2d411118085256fC53CBdDd137)
* [**Goerli (testnet)**](https://goerli.etherscan.io/address/0x3bc1A0Ad72417f2d411118085256fC53CBdDd137)

If you would like to use Hats on a chain not listed above, please reach out to us at support \[at] hatsprotocol \[dot] xyz.

# ðŸ¤– v1 Protocol Spec

In this section, you'll find Ethereum Natspec documentation for each of the contracts, events, errors, and interfaces that comprise Hats Protocol.

-------------------

# Hats.sol

## Overview

Hats are DAO-native, revocable, and programmable roles that are represented as non-transferable ERC-1155-similar tokens for composability.

This is a multi-tenant contract that can manage all hats for a given chain. While it fully implements the ERC1155 interface, it does not fully comply with the ERC1155 standard.

## State Variables

### name
The name of the contract, typically including the version
```solidity
string public name;
```

### lastTopHatId
The first 4 bytes of the id of the last tophat created.
```solidity
uint32 public lastTopHatId;
```

### baseImageURI
The fallback image URI for hat tokens with no `imageURI` specified in their branch
```solidity
string public baseImageURI;
```

### _hats
Internal mapping of hats to hat ids. See HatsIdUtilities.sol for more info on how hat ids work
```solidity
mapping(uint256 => Hat) internal _hats;
```

### badStandings
Mapping of wearers in bad standing for certain hats. Used by external contracts to trigger penalties for wearers in bad standing hatId => wearer => !standing
```solidity
mapping(uint256 => mapping(address => bool)) public badStandings;
```

## Functions

### constructor
All arguments are immutable; they can only be set once during construction
```solidity
constructor(string memory _name, string memory _baseImageURI);
```

**Parameters**
| Name            | Type     | Description                                                |
| --------------- | -------- | ---------------------------------------------------------- |
| `_name`         | `string` | The name of this contract, typically including the version |
| `_baseImageURI` | `string` | The fallback image URI                                     |

### mintTopHat
Creates and mints a Hat that is its own admin, i.e. a "topHat". A topHat has no eligibility and no toggle.
```solidity
function mintTopHat(address _target, string calldata _details, string calldata _imageURI)
    public
    returns (uint256 topHatId);
```

**Parameters**
| Name        | Type      | Description                                                                                                                                              |
| ----------- | --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `_target`   | `address` | The address to which the newly created topHat is minted                                                                                                  |
| `_details`  | `string`  | A description of the Hat [optional]. Should not be larger than 7000 bytes (enforced in changeHatDetails)                                                |
| `_imageURI` | `string`  | The image uri for this top hat and the fallback for its downstream hats [optional]. Should not be large than 7000 bytes (enforced in changeHatImageURI) |

**Returns**
| Name       | Type      | Description                        |
| ---------- | --------- | ---------------------------------- |
| `topHatId` | `uint256` | The id of the newly created topHat |

### createHat

Creates a new hat. The msg.sender must wear the `_admin` hat.

_Initializes a new Hat struct, but does not mint any tokens._

```solidity
function createHat(
    uint256 _admin,
    string calldata _details,
    uint32 _maxSupply,
    address _eligibility,
    address _toggle,
    bool _mutable,
    string calldata _imageURI
) public returns (uint256 newHatId);
```

**Parameters**
| Name           | Type      | Description                                                                                                                                           |
| -------------- | --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| `_admin`       | `uint256` | The id of the Hat that will control who wears the newly created hat                                                                                   |
| `_details`     | `string`  | A description of the Hat. Should not be larger than 7000 bytes (enforced in changeHatDetails)                                                         |
| `_maxSupply`   | `uint32`  | The total instances of the Hat that can be worn at once                                                                                               |
| `_eligibility` | `address` | The address that can report on the Hat wearer's status                                                                                                |
| `_toggle`      | `address` | The address that can deactivate the Hat                                                                                                               |
| `_mutable`     | `bool`    | Whether the hat's properties are changeable after creation                                                                                            |
| `_imageURI`    | `string`  | The image uri for this hat and the fallback for its downstream hats [optional]. Should not be larger than 7000 bytes (enforced in changeHatImageURI) |

**Returns**
| Name       | Type      | Description                     |
| ---------- | --------- | ------------------------------- |
| `newHatId` | `uint256` | The id of the newly created Hat |

#### batchCreateHats

Creates new hats in batch. The msg.sender must be an admin of each hat.

_This is a convenience function that loops through the arrays and calls `createHat`._

```solidity
function batchCreateHats(
    uint256[] calldata _admins,
    string[] calldata _details,
    uint32[] calldata _maxSupplies,
    address[] memory _eligibilityModules,
    address[] memory _toggleModules,
    bool[] calldata _mutables,
    string[] calldata _imageURIs
) public returns (bool success);
```

**Parameters**
| Name                  | Type        | Description                                                  |
| --------------------- | ----------- | ------------------------------------------------------------ |
| `_admins`             | `uint256[]` | Array of ids of admins for each hat to create                |
| `_details`            | `string[]`  | Array of details for each hat to create                      |
| `_maxSupplies`        | `uint32[]`  | Array of supply caps for each hat to create                  |
| `_eligibilityModules` | `address[]` | Array of eligibility module addresses for each hat to create |
| `_toggleModules`      | `address[]` | Array of toggle module addresses for each hat to create      |
| `_mutables`           | `bool[]`    | Array of mutable flags for each hat to create                |
| `_imageURIs`          | `string[]`  | Array of imageURIs for each hat to create                    |

**Returns**
| Name      | Type   | Description                           |
| --------- | ------ | ------------------------------------- |
| `success` | `bool` | True if all createHat calls succeeded |

### getNextId

Gets the id of the next child hat of the hat `_admin`

_Does not incrememnt lastHatId_

```solidity
function getNextId(uint256 _admin) public view returns (uint256 nextId);
```

**Parameters**
| Name     | Type      | Description                                                    |
| -------- | --------- | -------------------------------------------------------------- |
| `_admin` | `uint256` | The id of the hat to serve as the admin for the next child hat |

**Returns**
| Name     | Type      | Description    |
| -------- | --------- | -------------- |
| `nextId` | `uint256` | The new hat id |

### mintHat

Mints an ERC1155-similar token of the Hat to an eligible recipient, who then "wears" the hat

_The msg.sender must wear an admin Hat of `_hatId`, and the recipient must be eligible to wear `_hatId`_

```solidity
function mintHat(uint256 _hatId, address _wearer) public returns (bool success);
```

**Parameters**
| Name      | Type      | Description                            |
| --------- | --------- | -------------------------------------- |
| `_hatId`  | `uint256` | The id of the Hat to mint              |
| `_wearer` | `address` | The address to which the Hat is minted |

**Returns**
| Name      | Type   | Description                |
| --------- | ------ | -------------------------- |
| `success` | `bool` | Whether the mint succeeded |

### batchMintHats

Mints new hats in batch. The msg.sender must be an admin of each hat.

_This is a convenience function that loops through the arrays and calls `mintHat`._

```solidity
function batchMintHats(uint256[] calldata _hatIds, address[] calldata _wearers) public returns (bool success);
```

**Parameters**
| Name       | Type        | Description                                         |
| ---------- | ----------- | --------------------------------------------------- |
| `_hatIds`  | `uint256[]` | Array of ids of hats to mint                        |
| `_wearers` | `address[]` | Array of addresses to which the hats will be minted |

**Returns**
| Name      | Type   | Description                         |
| --------- | ------ | ----------------------------------- |
| `success` | `bool` | True if all mintHat calls succeeded |

### setHatStatus

Toggles a Hat's status from active to deactive, or vice versa

_The msg.sender must be set as the hat's toggle_

```solidity
function setHatStatus(uint256 _hatId, bool _newStatus) external returns (bool toggled);
```

**Parameters**
| Name         | Type      | Description                                  |
| ------------ | --------- | -------------------------------------------- |
| `_hatId`     | `uint256` | The id of the Hat for which to adjust status |
| `_newStatus` | `bool`    | The new status to set                        |

**Returns**
| Name      | Type   | Description                    |
| --------- | ------ | ------------------------------ |
| `toggled` | `bool` | Whether the status was toggled |

### checkHatStatus

Checks a hat's toggle module and processes the returned status

_May change the hat's status in storage_

```solidity
function checkHatStatus(uint256 _hatId) public returns (bool toggled);
```

**Parameters**
| Name     | Type      | Description                                    |
| -------- | --------- | ---------------------------------------------- |
| `_hatId` | `uint256` | The id of the Hat whose toggle we are checking |

**Returns**
| Name      | Type   | Description                    |
| --------- | ------ | ------------------------------ |
| `toggled` | `bool` | Whether there was a new status |

### _pullHatStatus

```solidity
function _pullHatStatus(Hat storage _hat, uint256 _hatId) internal view returns (bool success, bool newStatus);
```

### setHatWearerStatus

Report from a hat's eligibility on the status of one of its wearers and, if `false`, revoke their hat

_Burns the wearer's hat, if revoked_

```solidity
function setHatWearerStatus(uint256 _hatId, address _wearer, bool _eligible, bool _standing)
```

-------------------

# HatsEvents.sol

## HatsEvents

[Git Source](https://github.com/Hats-Protocol/hats-protocol/blob/b43ad0d1dbe4a4190febc036ee8a2849e3f221b4/src/Interfaces/HatsEvents.sol)

### Events

#### HatCreated

Emitted when a new hat is created

```solidity
event HatCreated(
    uint256 id, string details, uint32 maxSupply, address eligibility, address toggle, bool mutable_, string imageURI
);
```

#### WearerStandingChanged

Emitted when a hat wearer's standing is updated

_Eligibility is excluded since the source of truth for eligibility is the eligibility module and may change without a transaction_

```solidity
event WearerStandingChanged(uint256 hatId, address wearer, bool wearerStanding);
```

#### HatStatusChanged

Emitted when a hat's status is updated

```solidity
event HatStatusChanged(uint256 hatId, bool newStatus);
```

#### HatDetailsChanged

Emitted when a hat's details are updated

```solidity
event HatDetailsChanged(uint256 hatId, string newDetails);
```

#### HatEligibilityChanged

Emitted when a hat's eligibility module is updated

```solidity
event HatEligibilityChanged(uint256 hatId, address newEligibility);
```

#### HatToggleChanged

Emitted when a hat's toggle module is updated

```solidity
event HatToggleChanged(uint256 hatId, address newToggle);
```

#### HatMutabilityChanged

Emitted when a hat's mutability is updated

```solidity
event HatMutabilityChanged(uint256 hatId);
```

#### HatMaxSupplyChanged

Emitted when a hat's maximum supply is updated

```solidity
event HatMaxSupplyChanged(uint256 hatId, uint32 newMaxSupply);
```

#### HatImageURIChanged

Emitted when a hat's image URI is updated

```solidity
event HatImageURIChanged(uint256 hatId, string newImageURI);
```

#### TopHatLinkRequested

Emitted when a tophat linkage is requested by its admin

```solidity
event TopHatLinkRequested(uint32 domain, uint256 newAdmin);
```

#### TopHatLinked

Emitted when a tophat is linked to a another tree

```solidity
event TopHatLinked(uint32 domain, uint256 newAdmin);
```

# HatsErrors.sol

## HatsErrors

[Git Source](https://github.com/Hats-Protocol/hats-protocol/blob/b43ad0d1dbe4a4190febc036ee8a2849e3f221b4/src/Interfaces/HatsErrors.sol)

### Errors

#### NotAdmin

Emitted when `user` is attempting to perform an action on `hatId` but is not wearing one of `hatId`'s admin hats

_Can be equivalent to `NotHatWearer(buildHatId(hatId))`, such as when emitted by `approveLinkTopHatToTree` or `relinkTopHatToTree`_

```solidity
error NotAdmin(address user, uint256 hatId);
```

#### NotHatWearer

Emitted when attempting to perform an action as or for an account that is not a wearer of a given hat

```solidity
error NotHatWearer();
```

#### NotAdminOrWearer

Emitted when attempting to perform an action that requires being either an admin or wearer of a given hat

```solidity
error NotAdminOrWearer();
```

#### AllHatsWorn

Emitted when attempting to mint `hatId` but `hatId`'s maxSupply has been reached

```solidity
error AllHatsWorn(uint256 hatId);
```

#### MaxLevelsReached

Emitted when attempting to create a hat with a level 14 hat as its admin

```solidity
error MaxLevelsReached();
```

#### InvalidHatId

Emitted when an attempted hat id has empty intermediate level(s)

```solidity
error InvalidHatId();
```

#### AlreadyWearingHat

Emitted when attempting to mint `hatId` to a `wearer` who is already wearing the hat

```solidity
error AlreadyWearingHat(address wearer, uint256 hatId);
```

#### HatDoesNotExist

Emitted when attempting to mint a non-existant hat

```solidity
error HatDoesNotExist(uint256 hatId);
```

#### HatNotActive

Emmitted when attempting to mint or transfer a hat that is not active

```solidity
error HatNotActive();
```

#### NotEligible

Emitted when attempting to mint or transfer a hat to an ineligible wearer

```solidity
error NotEligible();
```

#### NotHatsToggle

Emitted when attempting to check or set a hat's status from an account that is not that hat's toggle module

```solidity
error NotHatsToggle();
```

#### NotHatsEligibility

Emitted when attempting to check or set a hat wearer's status from an account that is not that hat's eligibility module

```solidity
error NotHatsEligibility();
```

#### BatchArrayLengthMismatch

Emitted when array arguments to a batch function have mismatching lengths

```solidity
error BatchArrayLengthMismatch();
```

#### Immutable

Emitted when attempting to mutate or transfer an immutable hat

```solidity
error Immutable();
```

#### NewMaxSupplyTooLow

Emitted when attempting to change a hat's maxSupply to a value lower than its current supply

```solidity
error NewMaxSupplyTooLow();
```

#### CircularLinkage

Emitted when attempting to link a tophat to a new admin for which the tophat serves as an admin

```solidity
error CircularLinkage();
```

#### CrossTreeLinkage

Emitted when attempting to link or relink a tophat to a separate tree

```solidity
error CrossTreeLinkage();
```

#### LinkageNotRequested

Emitted when attempting to link a tophat without a request

```solidity
error LinkageNotRequested();
```

#### InvalidUnlink

Emitted when attempting to unlink a tophat that does not have a wearer

_This ensures that unlinking never results in a bricked tophat_

```solidity
error InvalidUnlink();
```

#### ZeroAddress

Emmited when attempting to change a hat's eligibility or toggle module to the zero address

```solidity
error ZeroAddress();
```

#### StringTooLong

Emmitted when attempting to change a hat's details or imageURI to a string with over 7000 bytes (~characters)

_This protects against a DOS attack where an admin iteratively extend's a hat's details or imageURI to be so long that reading it exceeds the block gas limit, breaking `uri()` and `viewHat()`_

```solidity
error StringTooLong();
```

# HatsIdUtilities.sol

## HatsIdUtilities

[Git Source](https://github.com/Hats-Protocol/hats-protocol/blob/b43ad0d1dbe4a4190febc036ee8a2849e3f221b4/src/HatsIdUtilities.sol)

**Inherits:** IHatsIdUtilities

**Author:** Haberdasher Labs

_Functions for working with Hat Ids from Hats Protocol. Factored out of Hats.sol for easier use by other contracts._

### State Variables

#### linkedTreeRequests

Mapping of tophats requesting to link to admin hats in other trees

_Linkage only occurs if request is approved by the new admin_

```solidity
mapping(uint32 => uint256) public linkedTreeRequests;
```

#### linkedTreeAdmins

Mapping of approved & linked tophats to admin hats in other trees, used for grafting one hats tree onto another

_Trees can only be linked to another tree via their tophat_

```solidity
mapping(uint32 => uint256) public linkedTreeAdmins;
```

#### TOPHAT\_ADDRESS\_SPACE

Hat Ids serve as addresses. A given Hat's Id represents its location in its hat tree: its level, its admin, its admin's admin (etc, all the way up to the tophat). The top level consists of 4 bytes and references all tophats. Each level below consists of 16 bits, and contains up to 65,536 child hats. A uint256 contains 4 bytes of space for tophat addresses, giving room for ((256 - 32) / 16) = 14 levels of delegation, with the admin at each level having space for 65,536 different child hats. A hat tree consists of a single tophat and has a max depth of 14 levels.

_Number of bits of address space for tophat ids, ie the tophat domain_

```solidity
uint256 internal constant TOPHAT_ADDRESS_SPACE = 32;
```

#### LOWER\_LEVEL\_ADDRESS\_SPACE

_Number of bits of address space for each level below the tophat_

```solidity
uint256 internal constant LOWER_LEVEL_ADDRESS_SPACE = 16;
```

#### MAX\_LEVELS

_Maximum number of levels below the tophat, ie max tree depth (256 - TOPHAT\_ADDRESS\_SPACE) / LOWER\_LEVEL\_ADDRESS\_SPACE;_

```solidity
uint256 internal constant MAX_LEVELS = 14;
```

### Functions

#### buildHatId

Constructs a valid hat id for a new hat underneath a given admin

_Reverts if the admin has already reached `MAX_LEVELS`_

```solidity
function buildHatId(uint256 _admin, uint16 _newHat) public pure returns (uint256 id);
```

**Parameters**

| Name      | Type      | Description                         |
| --------- | --------- | ----------------------------------- |
| `_admin`  | `uint256` | the id of the admin for the new hat |
| `_newHat` | `uint16`  | the uint16 id of the new hat        |

**Returns**

| Name | Type      | Description            |
| ---- | --------- | ---------------------- |
| `id` | `uint256` | The constructed hat id |

#### getHatLevel

Identifies the level a given hat in its hat tree

```solidity
function getHatLevel(uint256 _hatId) public view returns (uint32 level);
```

**Parameters**

| Name     | Type      | Description                   |
| -------- | --------- | ----------------------------- |
| `_hatId` | `uint256` | the id of the hat in question |

**Returns**

| Name    | Type     | Description             |
| ------- | -------- | ----------------------- |
| `level` | `uint32` | (0 to type(uint32).max) |

#### getLocalHatLevel

Identifies the level a given hat in its local hat tree

_Similar to getHatLevel, but does not account for linked trees_

```solidity
function getLocalHatLevel(uint256 _hatId) public pure returns (uint32 level);
```

**Parameters**

| Name     | Type      | Description                   |
| -------- | --------- | ----------------------------- |
| `_hatId` | `uint256` | the id of the hat in question |

**Returns**

| Name    | Type     | Description                   |
| ------- | -------- | ----------------------------- |
| `level` | `uint32` | The local level, from 0 to 14 |

#### isTopHat

Checks whether a hat is a topHat

```solidity
function isTopHat(uint256 _hatId) public view returns (bool _isTopHat);
```

**Parameters**

| Name     | Type      | Description         |
| -------- | --------- | ------------------- |
| `_hatId` | `uint256` | The hat in question |

**Returns**

| Name        | Type   | Description                 |
| ----------- | ------ | --------------------------- |
| `_isTopHat` | `bool` | Whether the hat is a topHat |

#### isLocalTopHat

Checks whether a hat is a topHat in its local hat tree

_Similar to isTopHat, but does not account for linked trees_

```solidity
function isLocalTopHat(uint256 _hatId) public pure returns (bool _isLocalTopHat);
```

**Parameters**

| Name     | Type      | Description         |
| -------- | --------- | ------------------- |
| `_hatId` | `uint256` | The hat in question |

**Returns**

| Name             | Type   | Description                                    |
| ---------------- | ------ | ---------------------------------------------- |
| `_isLocalTopHat` | `bool` | Whether the hat is a topHat for its local tree |

#### isValidHatId

```solidity
function isValidHatId(uint256 _hatId) public pure returns (bool validHatId);
```

#### getAdminAtLevel

Gets the hat id of the admin at a given level of a given hat

_This function traverses trees by following the linkedTreeAdmin pointer to a hat located in a different tree_

```solidity
function getAdminAtLevel(uint256 _hatId, uint32 _level) public view returns (uint256 admin);
```

**Parameters**

| Name     | Type      | Description                   |
| -------- | --------- | ----------------------------- |
| `_hatId` | `uint256` | the id of the hat in question |
| `_level` | `uint32`  | the admin level of interest   |

**Returns**

| Name    | Type      | Description                       |
| ------- | --------- | --------------------------------- |
| `admin` | `uint256` | The hat id of the resulting admin |

#### getAdminAtLocalLevel

Gets the hat id of the admin at a given level of a given hat local to the tree containing the hat.

```solidity
function getAdminAtLocalLevel(uint256 _hatId, uint32 _level) public pure returns (uint256 admin);
```

**Parameters**

| Name     | Type      | Description                   |
| -------- | --------- | ----------------------------- |
| `_hatId` | `uint256` | the id of the hat in question |
| `_level` | `uint32`  | the admin level of interest   |

**Returns**

| Name    | Type      | Description                       |
| ------- | --------- | --------------------------------- |
| `admin` | `uint256` | The hat id of the resulting admin |

#### getTopHatDomain

Gets the tophat domain of a given hat

_A domain is the identifier for a given hat tree, stored in the first 4 bytes of a hat's id_

```solidity
function getTopHatDomain(uint256 _hatId) public pure returns (uint32 domain);
```

**Parameters**

| Name     | Type      | Description                   |
| -------- | --------- | ----------------------------- |
| `_hatId` | `uint256` | the id of the hat in question |

**Returns**

| Name     | Type     | Description                    |
| -------- | -------- | ------------------------------ |
| `domain` | `uint32` | The domain of the hat's tophat |

#### getTippyTopHatDomain

Gets the domain of the highest parent tophat â€” the "tippy tophat"

```solidity
function getTippyTopHatDomain(uint32 _topHatDomain) public view returns (uint32 domain);
```

**Parameters**

| Name            | Type     | Description                                   |
| --------------- | -------- | --------------------------------------------- |
| `_topHatDomain` | `uint32` | the 32 bit domain of a (likely linked) tophat |

**Returns**

| Name     | Type     | Description             |
| -------- | -------- | ----------------------- |
| `domain` | `uint32` | The tippy tophat domain |

#### noCircularLinkage

Checks For any circular linkage of trees

```solidity
function noCircularLinkage(uint32 _topHatDomain, uint256 _linkedAdmin) public view returns (bool notCircular);
```

**Parameters**

| Name            | Type      | Description                                |
| --------------- | --------- | ------------------------------------------ |
| `_topHatDomain` | `uint32`  | the 32 bit domain of the tree to be linked |
| `_linkedAdmin`  | `uint256` | the hatId of the potential tree admin      |

**Returns**

| Name          | Type   | Description                      |
| ------------- | ------ | -------------------------------- |
| `notCircular` | `bool` | circular link has not been found |

#### sameTippyTopHatDomain

Checks that a tophat domain and its potential linked admin are from the same tree, ie have the same tippy tophat domain

```solidity
function sameTippyTopHatDomain(uint32 _topHatDomain, uint256 _newAdminHat) public view returns (bool sameDomain);
```

**Parameters**

| Name            | Type      | Description                                  |
| --------------- | --------- | -------------------------------------------- |
| `_topHatDomain` | `uint32`  | The 32 bit domain of the tophat to be linked |
| `_newAdminHat`  | `uint256` | The new admin for the linked tree            |

**Returns**

| Name         | Type   | Description                                                                                          |
| ------------ | ------ | ---------------------------------------------------------------------------------------------------- |
| `sameDomain` | `bool` | Whether the \_topHatDomain and the domain of its potential linked \_newAdminHat domains are the same |

# IHats.sol

## IHats

[Git Source](https://github.com/Hats-Protocol/hats-protocol/blob/b43ad0d1dbe4a4190febc036ee8a2849e3f221b4/src/Interfaces/IHats.sol)

**Inherits:** IHatsIdUtilities, HatsErrors, HatsEvents

### Functions

#### mintTopHat

```solidity
function mintTopHat(address _target, string memory _details, string memory _imageURI)
    external
    returns (uint256 topHatId);
```

#### createHat

```solidity
function createHat(
    uint256 _admin,
    string calldata _details,
    uint32 _maxSupply,
    address _eligibility,
    address _toggle,
    bool _mutable,
    string calldata _imageURI
) external returns (uint256 newHatId);
```

#### batchCreateHats

```solidity
function batchCreateHats(
    uint256[] calldata _admins,
    string[] calldata _details,
    uint32[] calldata _maxSupplies,
    address[] memory _eligibilityModules,
    address[] memory _toggleModules,
    bool[] calldata _mutables,
    string[] calldata _imageURIs
) external returns (bool success);
```

#### getNextId

```solidity
function getNextId(uint256 _admin) external view returns (uint256 nextId);
```

#### mintHat

```solidity
function mintHat(uint256 _hatId, address _wearer) external returns (bool success);
```

#### batchMintHats

```solidity
function batchMintHats(uint256[] calldata _hatIds, address[] calldata _wearers) external returns (bool success);
```

#### setHatStatus

```solidity
function setHatStatus(uint256 _hatId, bool _newStatus) external returns (bool toggled);
```

#### checkHatStatus

```solidity
function checkHatStatus(uint256 _hatId) external returns (bool toggled);
```

#### setHatWearerStatus

```solidity
function setHatWearerStatus(uint256 _hatId, address _wearer, bool _eligible, bool _standing)
    external
    returns (bool updated);
```

#### checkHatWearerStatus

```solidity
function checkHatWearerStatus(uint256 _hatId, address _wearer) external returns (bool updated);
```

#### renounceHat

```solidity
function renounceHat(uint256 _hatId) external;
```

#### transferHat

```solidity
function transferHat(uint256 _hatId, address _from, address _to) external;
```

#### makeHatImmutable

```solidity
function makeHatImmutable(uint256 _hatId) external;
```

#### changeHatDetails

```solidity
function changeHatDetails(uint256 _hatId, string memory _newDetails) external;
```

#### changeHatEligibility

```solidity
function changeHatEligibility(uint256 _hatId, address _newEligibility) external;
```

#### changeHatToggle

```solidity
function changeHatToggle(uint256 _hatId, address _newToggle) external;
```

#### changeHatImageURI

```solidity
function changeHatImageURI(uint256 _hatId, string memory _newImageURI) external;
```

#### changeHatMaxSupply

```solidity
function changeHatMaxSupply(uint256 _hatId, uint32 _newMaxSupply) external;
```

#### requestLinkTopHatToTree

```solidity
function requestLinkTopHatToTree(uint32 _topHatId, uint256 _newAdminHat) external;
```

#### approveLinkTopHatToTree

```solidity
function approveLinkTopHatToTree(
    uint32 _topHatId,
    uint256 _newAdminHat,
    address _eligibility,
    address _toggle,
    string calldata _details,
    string calldata _imageURI
) external;
```

#### unlinkTopHatFromTree

```solidity
function unlinkTopHatFromTree(uint32 _topHatId, address _wearer) external;
```

#### relinkTopHatWithinTree

```solidity
function relinkTopHatWithinTree(
    uint32 _topHatDomain,
    uint256 _newAdminHat,
    address _eligibility,
    address _toggle,
    string calldata _details,
    string calldata _imageURI
) external;
```

#### viewHat

```solidity
function viewHat(uint256 _hatId)
    external
    view
    returns (
        string memory details,
        uint32 maxSupply,
        uint32 supply,
        address eligibility,
        address toggle,
        string memory imageURI,
        uint16 lastHatId,
        bool mutable_,
        bool active
    );
```

#### isWearerOfHat

```solidity
function isWearerOfHat(address _user, uint256 _hatId) external view returns (bool isWearer);
```

#### isAdminOfHat

```solidity
function isAdminOfHat(address _user, uint256 _hatId) external view returns (bool isAdmin);
```

#### isInGoodStanding

```solidity
function isInGoodStanding(address _wearer, uint256 _hatId) external view returns (bool standing);
```

#### isEligible

```solidity
function isEligible(address _wearer, uint256 _hatId) external view returns (bool eligible);
```

#### getHatEligibilityModule

```solidity
function getHatEligibilityModule(uint256 _hatId) external view returns (address eligibility);
```

#### getHatToggleModule

```solidity
function getHatToggleModule(uint256 _hatId) external view returns (address toggle);
```

#### getHatMaxSupply

```solidity
function getHatMaxSupply(uint256 _hatId) external view returns (uint32 maxSupply);
```

#### hatSupply

```solidity
function hatSupply(uint256 _hatId) external view returns (uint32 supply);
```

#### getImageURIForHat

```solidity
function getImageURIForHat(uint256 _hatId) external view returns (string memory _uri);
```

#### balanceOf

```solidity
function balanceOf(address wearer, uint256 hatId) external view returns (uint256 balance);
```

#### balanceOfBatch

```solidity
function balanceOfBatch(address[] calldata _wearers, uint256[] calldata _hatIds)
    external
    view
    returns (uint256[] memory);
```

#### uri

```solidity
function uri(uint256 id) external view returns (string memory _uri);
```

# IHatsIdUtilities.sol

## IHatsIdUtilities

[Git Source](https://github.com/Hats-Protocol/hats-protocol/blob/b43ad0d1dbe4a4190febc036ee8a2849e3f221b4/src/Interfaces/IHatsIdUtilities.sol)

### Functions

#### buildHatId

```solidity
function buildHatId(uint256 _admin, uint16 _newHat) external pure returns (uint256 id);
```

#### getHatLevel

```solidity
function getHatLevel(uint256 _hatId) external view returns (uint32 level);
```

#### getLocalHatLevel

```solidity
function getLocalHatLevel(uint256 _hatId) external pure returns (uint32 level);
```

#### isTopHat

```solidity
function isTopHat(uint256 _hatId) external view returns (bool _topHat);
```

#### isLocalTopHat

```solidity
function isLocalTopHat(uint256 _hatId) external pure returns (bool _localTopHat);
```

#### isValidHatId

```solidity
function isValidHatId(uint256 _hatId) external view returns (bool validHatId);
```

#### getAdminAtLevel

```solidity
function getAdminAtLevel(uint256 _hatId, uint32 _level) external view returns (uint256 admin);
```

#### getAdminAtLocalLevel

```solidity
function getAdminAtLocalLevel(uint256 _hatId, uint32 _level) external pure returns (uint256 admin);
```

#### getTopHatDomain

```solidity
function getTopHatDomain(uint256 _hatId) external view returns (uint32 domain);
```

#### getTippyTopHatDomain

```solidity
function getTippyTopHatDomain(uint32 _topHatDomain) external view returns (uint32 domain);
```

#### noCircularLinkage

```solidity
function noCircularLinkage(uint32 _topHatDomain, uint256 _linkedAdmin) external view returns (bool notCircular);
```

#### sameTippyTopHatDomain

```solidity
function sameTippyTopHatDomain(uint32 _topHatDomain, uint256 _newAdminHat) external view returns (bool sameDomain);
```

# IHatsEligibility.sol

## IHatsEligibility

[Git Source](https://github.com/Hats-Protocol/hats-protocol/blob/b43ad0d1dbe4a4190febc036ee8a2849e3f221b4/src/Interfaces/IHatsEligibility.sol)

### Functions

#### getWearerStatus

Returns the status of a wearer for a given hat

_If standing is false, eligibility MUST also be false_

```solidity
function getWearerStatus(address _wearer, uint256 _hatId) external view returns (bool eligible, bool standing);
```

**Parameters**
| Name      | Type      | Description                                          |
| --------- | --------- | ---------------------------------------------------- |
| `_wearer` | `address` | The address of the current or prospective Hat wearer |
| `_hatId`  | `uint256` | The id of the hat in question                        |

**Returns**
| Name       | Type   | Description                                   |
| ---------- | ------ | --------------------------------------------- |
| `eligible` | `bool` | Whether the _wearer is eligible to wear the hat |
| `standing` | `bool` | Whether the _wearer is in good standing        |

-------------------

# IHatsToggle.sol

## IHatsToggle

[Git Source](https://github.com/Hats-Protocol/hats-protocol/blob/b43ad0d1dbe4a4190febc036ee8a2849e3f221b4/src/Interfaces/IHatsToggle.sol)

### Functions

#### getHatStatus

```solidity
function getHatStatus(uint256 _hatId) external view returns (bool);
```

**Parameters**
| Name     | Type      | Description                   |
| -------- | --------- | ----------------------------- |
| `_hatId` | `uint256` | The id of the hat in question |

**Returns**
| Name | Type   | Description                                        |
| ---- | ------ | -------------------------------------------------- |
| -    | `bool` | Whether the hat is active (true) or inactive (false) |

-------------------

# ðŸ–¥ï¸ v1 SDK Core

Hats Protocol v1 Core and Subgraph SDKs.&#x20;

Check out the open source code [here](https://github.com/Hats-Protocol/sdk-v1-core).

# Getting Started

## Install

yarn:
```bash
yarn add @hatsprotocol/sdk-v1-core
```

npm:
```bash
npm install @hatsprotocol/sdk-v1-core
```

## HatsClient Initialization

Import and initialize HatsClient with a Viem client.

```typescript
import { HatsClient } from '@hatsprotocol/sdk-v1-core';
import { createPublicClient, http } from 'viem';
import { optimism } from 'viem/chains';

const transport = http('YOUR_RPC_URL');
const publicClient = createPublicClient({
  chain: optimism,
  transport,
});

const hatsClient = new HatsClient({
  chainId: 10, // optimism
  publicClient,
});
```

**Arguments**:
```typescript
{
  chainId: number;
  publicClient: PublicClient;
}
```

# Onchain Reads

## viewHat

Get a Hat's properties.

```typescript
const hat = await hatsClient.viewHat({
  hatId,
});
```

**Arguments**:
```typescript
{
  hatId: bigint;
}
```
- `hatId` - ID of the Hat to view.

**Response**:
```typescript
{
  details: string;
  maxSupply: bigint;
  eligibility: `0x${string}`;
  toggle: `0x${string}`;
  mutable: boolean;
  imageUri: string;
  status: boolean;
  admin: bigint;
}
```
- `details` - Hat's details field.
- `maxSupply` - Maximum amount of wearers.
- `eligibility` - Eligibility module address.
- `toggle` - Toggle module address.
- `mutable` - Whether the Hat is mutable.
- `imageUri` - Hat's image URI.
- `status` - Whether the Hat is active.
- `admin` - Hat's admin Hat ID.

## isWearerOfHat

Check if an address wears a specific hat.

```typescript
const isWearer = await hatsClient.isWearerOfHat({
  wearer,
  hatId,
});
```

**Arguments**:
```typescript
{
  wearer: Address;
  hatId: bigint;
}
```
- `wearer` - address to check whether wearing the hat.
- `hatId` - hat's ID.

**Response**:
```typescript
boolean;
```
`true` if the given address wears the hat, `false` otherwise.

## isActive

Check if a hat is active.

```typescript
const isActive = await hatsClient.isActive(hatId);
```

**Arguments**:
```typescript
hatId: bigint;
```
`hatId` - hat's ID.

**Response**:
```typescript
boolean;
```
`true` if the given hat is active, `false` otherwise.

### isInGoodStanding

Check if a wearer is in good standing for a given hat.

```typescript
const isGoodStanding = await hatsClient.isInGoodStanding({
  wearer,
  hatId,
});
```

**Arguments**:
```typescript
{
  wearer: Address;
  hatId: bigint;
}
```
- `wearer` - address to check whether in good standing.
- `hatId` - hat's ID.

**Response**:
```typescript
boolean;
```
`true` if the given wearer is in good standing, `false` otherwise.

## isEligible

Check if an address is eligible for a specific hat.

```typescript
const isEligible = await hatsClient.isEligible({
  wearer,
  hatId,
});
```

**Arguments**:
```typescript
{
  wearer: Address;
  hatId: bigint;
}
```
- `wearer` - address to check whether is eligible.
- `hatId` - hat's ID.

**Response**:
```typescript
boolean;
```
`true` if the given address is eligible for the hat, `false` otherwise.

## predictHatId

Predict the ID of a yet to be created hat.

```typescript
const hatId = await hatsClient.predictHatId(admin);
```

**Arguments**:
```typescript
admin: bigint;
```
`admin` - parent hat of the would be created one.

**Response**:
```typescript
bigint;
```
Hat ID of the would be created hat.

### getTreesCount

Get the number of existing trees.

```typescript
const numTrees = await hatsClient.getTreesCount();
```

**Response**:
```typescript
number;
```
Current number of trees.

## getLinkageRequest

Get the linkage request of a tree.

```typescript
const requestedAdminHat = await hatsClient.getLinkageRequest(topHatDomain);
```

**Arguments**:
```typescript
topHatDomain: number;
```
`topHatDomain` - the tree domain. The tree domain is the first four bytes of the tophat ID.

**Response**:
```typescript
bigint;
```
If request exists, returns the requested new admin hat ID. If not, returns zero.

### getLinkedTreeAdmin

Get the admin of a linked tree.

```typescript
const linkedTreeAdmin = await hatsClient.getLinkedTreeAdmin({
  hatId,
});
```

**Arguments**:
```typescript
{
  hatId: bigint;
}
```
- `hatId` - ID of a Hat in the tree to check.

**Response**:
```typescript
bigint;
```
The ID of the admin Hat of the linked tree.

### getHatLevel

Get a Hat's level in the global tree.

```typescript
const level = await hatsClient.getHatLevel({
  hatId,
});
```

**Arguments**:
```typescript
{
  hatId: bigint;
}
```
- `hatId` - ID of the Hat to check.

**Response**:
```typescript
number;
```
The level of the Hat in the global tree.

## getLocalHatLevel

Get a Hat's level in its local tree.

```typescript
const localLevel = await hatsClient.getLocalHatLevel({
  hatId,
});
```

**Arguments**:
```typescript
{
  hatId: bigint;
}
```
- `hatId` - ID of the Hat to check.

**Response**:
```typescript
number;
```
The level of the Hat in its local tree.

## getTopHatDomain

Get a Hat's tree domain.

```typescript
const domain = await hatsClient.getTopHatDomain({
  hatId,
});
```

**Arguments**:
```typescript
{
  hatId: bigint;
}
```
- `hatId` - ID of the Hat to check.

**Response**:
```typescript
number;
```
The domain of the tree that contains the Hat.

### getTippyTopHatDomain

Get the tree domain of the global tree's tophat.

```typescript
const domain = await hatsClient.getTippyTopHatDomain({
  hatId,
});
```

**Arguments**:
```typescript
{
  hatId: bigint;
}
```
- `hatId` - ID of a Hat in the tree to check.

**Response**:
```typescript
number;
```
The domain of the global tree's tophat.

# Onchain Writes

## mintTopHat

Mint a new top hat.

```typescript
const result = await hatsClient.mintTopHat({
  account,
  target,
  details,
  imageURI,
});
```

**Arguments**:
```typescript
{
    account: Account;
    target: `0x${string}`;
    details: string;
    imageURI?: string;
}
```

- `account` - Viem account to send the transaction from.
- `target` - Address to mint the top hat to.
- `details` - Top hat's details field.
- `imageURI` (Optional) - Top hat's image URI.

**Response**:
```typescript
{
  status: 'success' | 'reverted';
  transactionHash: `0x${string}`;
  hatId: bigint;
}
```

- `status` - "success" if transaction was successful, "reverted" if transaction reverted.
- `transactionHash` - Transaction's hash.
- `hatId` - ID of the newly created top hat.

## createHat

Create a new hat.

```typescript
const result = await hatsClient.createHat({
  account,
  admin,
  details,
  maxSupply,
  eligibility,
  toggle,
  mutable,
  imageURI,
});
```

**Arguments**:
```typescript
{
    account: Account;
    admin: bigint;
    details: string;
    maxSupply: bigint;
    eligibility: `0x${string}`;
    toggle: `0x${string}`;
    mutable: boolean;
    imageURI?: string;
}
```

- `account` - Viem account to send the transaction from.
- `admin` - ID of the admin hat.
- `details` - Hat's details field.
- `maxSupply` - Maximum amount of wearers.
- `eligibility` - Eligibility module address.
- `toggle` - Toggle module address.
- `mutable` - Whether the hat is mutable.
- `imageURI` (Optional) - Hat's image URI.

**Response**:
```typescript
{
  status: 'success' | 'reverted';
  transactionHash: `0x${string}`;
  hatId: bigint;
}
```

- `status` - "success" if transaction was successful, "reverted" if transaction reverted.
- `transactionHash` - Transaction's hash.
- `hatId` - ID of the newly created hat.

## batchCreateHats

Create multiple hats in one transaction.

```typescript
const result = await hatsClient.batchCreateHats({
  account,
  admins,
  details,
  maxSupplies,
  eligibilityModules,
  toggleModules,
  mutables,
  imageURIs,
});
```

**Arguments**:
```typescript
{
    account: Account;
    admins: bigint[];
    details: string[];
    maxSupplies: bigint[];
    eligibilityModules: `0x${string}`[];
    toggleModules: `0x${string}`[];
    mutables: boolean[];
    imageURIs?: string[];
}
```

- `account` - Viem account to send the transaction from.
- `admins` - IDs of the admin hats.
- `details` - Hats' details fields.
- `maxSupplies` - Maximum amounts of wearers.
- `eligibilityModules` - Eligibility module addresses.
- `toggleModules` - Toggle module addresses.
- `mutables` - Whether the hats are mutable.
- `imageURIs` (Optional) - Hats' image URIs.

**Response**:
```typescript
{
    status: "success" | "reverted";
    transactionHash: `0x${string}`;
    hatIds: bigint[];
}
```

- `status` - "success" if transaction was successful, "reverted" if transaction reverted.
- `transactionHash` - Transaction's hash.
- `hatIds` - IDs of the newly created hats.

## mintHat

Mint a hat to a wearer.

```typescript
const result = await hatsClient.mintHat({
  account,
  hatId,
  wearer,
});
```

**Arguments**:
```typescript
{
  account: Account;
  hatId: bigint;
  wearer: `0x${string}`;
}
```

- `account` - Viem account to send the transaction from.
- `hatId` - ID of the hat to mint.
- `wearer` - Address to mint the hat to.

**Response**:
```typescript
{
  status: 'success' | 'reverted';
  transactionHash: `0x${string}`;
}
```

- `status` - "success" if transaction was successful, "reverted" if transaction reverted.
- `transactionHash` - Transaction's hash.

## batchMintHats

Mint multiple hats to multiple wearers in one transaction.

```typescript
const result = await hatsClient.batchMintHats({
  account,
  hatIds,
  wearers,
});
```

**Arguments**:
```typescript
{
    account: Account;
    hatIds: bigint[];
    wearers: `0x${string}`[];
}
```

- `account` - Viem account to send the transaction from.
- `hatIds` - IDs of the hats to mint.
- `wearers` - Addresses to mint the hats to.

**Response**:
```typescript
{
  status: 'success' | 'reverted';
  transactionHash: `0x${string}`;
}
```

- `status` - "success" if transaction was successful, "reverted" if transaction reverted.
- `transactionHash` - Transaction's hash.

### setHatStatus

Set a hat's status.

```typescript
const result = await hatsClient.setHatStatus({
  account,
  hatId,
  newStatus,
});
```

**Arguments**:
```typescript
{
  account: Account;
  hatId: bigint;
  newStatus: boolean;
}
```

- `account` - Viem account to send the transaction from.
- `hatId` - ID of the hat to set status for.
- `newStatus` - New status to set.

**Response**:
```typescript
{
  status: 'success' | 'reverted';
  transactionHash: `0x${string}`;
}
```

- `status` - "success" if transaction was successful, "reverted" if transaction reverted.
- `transactionHash` - Transaction's hash.

## checkHatStatus

Check a hat's status and return whether it was toggled.

```typescript
const result = await hatsClient.checkHatStatus({
  account,
  hatId,
});
```

**Arguments**:
```typescript
{
  account: Account;
  hatId: bigint;
}
```

- `account` - Viem account to send the transaction from.
- `hatId` - ID of the hat to check status for.

**Response**:
```typescript
{
  status: 'success' | 'reverted';
  transactionHash: `0x${string}`;
  toggled: boolean;
}
```

- `status` - "success" if transaction was successful, "reverted" if transaction reverted.
- `transactionHash` - Transaction's hash.
- `toggled` - Whether the hat's status was toggled.

## setHatWearerStatus

Set a hat's wearer status.

```typescript
const result = await hatsClient.setHatWearerStatus({
  account,
  hatId,
  wearer,
  eligible,
  standing,
});
```

**Arguments**:
```typescript
{
  account: Account;
  hatId: bigint;
  wearer: `0x${string}`;
  eligible: boolean;
  standing: boolean;
}
```

- `account` - Viem account to send the transaction from.
- `hatId` - ID of the hat to set wearer status for.
- `wearer` - Address of the wearer to set status for.
- `eligible` - Whether the wearer is eligible.
- `standing` - Whether the wearer is in good standing.

**Response**:
```typescript
{
  status: 'success' | 'reverted';
  transactionHash: `0x${string}`;
}
```

- `status` - "success" if transaction was successful, "reverted" if transaction reverted.
- `transactionHash` - Transaction's hash.

## checkHatWearerStatus

Check a wearer's status and burn the hat if ineligible or in bad standing.

```typescript
const result = await hatsClient.checkHatWearerStatus({
  account,
  hatId,
  wearer,
});
```

**Arguments**:
```typescript
{
  account: Account;
  hatId: bigint;
  wearer: `0x${string}`;
}
```

- `account` - Viem account to send the transaction from.
- `hatId` - ID of the hat to check wearer status for.
- `wearer` - Address of the wearer to check status for.

**Response**:
```typescript
{
  status: 'success' | 'reverted';
  transactionHash: `0x${string}`;
  eligible: boolean;
  standing: boolean;
}
```

- `status` - "success" if transaction was successful, "reverted" if transaction reverted.
- `transactionHash` - Transaction's hash.
- `eligible` - Whether the wearer is eligible.
- `standing` - Whether the wearer is in good standing.

### renounceHat

Burn the hat for the caller.

```typescript
const result = await hatsClient.renounceHat({
  account,
  hatId,
});
```

**Arguments**:
```typescript
{
  account: Account;
  hatId: bigint;
}
```

- `account` - Viem account to send the transaction from.
- `hatId` - ID of the hat to renounce.

**Response**:
```typescript
{
  status: 'success' | 'reverted';
  transactionHash: `0x${string}`;
}
```

- `status` - "success" if transaction was successful, "reverted" if transaction reverted.
- `transactionHash` - Transaction's hash.

## transferHat

Transfer a hat from one wearer to another.

```typescript
const result = await hatsClient.transferHat({
  account,
  hatId,
  from,
  to,
});
```

**Arguments**:
```typescript
{
  account: Account;
  hatId: bigint;
  from: `0x${string}`;
  to: `0x${string}`;
}
```

- `account` - Viem account to send the transaction from.
- `hatId` - ID of the hat to transfer.
- `from` - Address to transfer the hat from.
- `to` - Address to transfer the hat to.

**Response**:
```typescript
{
  status: 'success' | 'reverted';
  transactionHash: `0x${string}`;
}
```

- `status` - "success" if transaction was successful, "reverted" if transaction reverted.
- `transactionHash` - Transaction's hash.

## makeHatImmutable

Make a hat immutable.

```typescript
const result = await hatsClient.makeHatImmutable({
  account,
  hatId,
});
```

**Arguments**:
```typescript
{
  account: Account;
  hatId: bigint;
}
```

- `account` - Viem account to send the transaction from.
- `hatId` - ID of the hat to make immutable.

**Response**:
```typescript
{
  status: 'success' | 'reverted';
  transactionHash: `0x${string}`;
}
```

- `status` - "success" if transaction was successful, "reverted" if transaction reverted.
- `transactionHash` - Transaction's hash.

## changeHatDetails

Change a hat's details.

```typescript
const result = await hatsClient.changeHatDetails({
  account,
  hatId,
  newDetails,
});
```

**Arguments**:
```typescript
{
  account: Account;
  hatId: bigint;
  newDetails: string;
}
```

- `account` - Viem account to send the transaction from.
- `hatId` - ID of the hat to change details for.
- `newDetails` - New details to set.

**Response**:
```typescript
{
  status: 'success' | 'reverted';
  transactionHash: `0x${string}`;
}
```

- `status` - "success" if transaction was successful, "reverted" if transaction reverted.
- `transactionHash` - Transaction's hash.

## changeHatEligibility

Change a hat's eligibility module.

```typescript
const result = await hatsClient.changeHatEligibility({
  account,
  hatId,
  newEligibility,
});
```

**Arguments**:
```typescript
{
  account: Account;
  hatId: bigint;
  newEligibility: `0x${string}`;
}
```

- `account` - Viem account to send the transaction from.
- `hatId` - ID of the hat to change eligibility for.
- `newEligibility` - New eligibility module address.

**Response**:
```typescript
{
  status: 'success' | 'reverted';
  transactionHash: `0x${string}`;
}
```

- `status` - "success" if transaction was successful, "reverted" if transaction reverted.
- `transactionHash` - Transaction's hash.

## changeHatToggle

Change a hat's toggle module.

```typescript
const result = await hatsClient.changeHatToggle({
  account,
  hatId,
  newToggle,
});
```

**Arguments**:
```typescript
{
  account: Account;
  hatId: bigint;
  newToggle: `0x${string}`;
}
```

- `account` - Viem account to send the transaction from.
- `hatId` - ID of the hat to change toggle for.
- `newToggle` - New toggle module address.

**Response**:
```typescript
{
  status: 'success' | 'reverted';
  transactionHash: `0x${string}`;
}
```

- `status` - "success" if transaction was successful, "reverted" if transaction reverted.
- `transactionHash` - Transaction's hash.

## changeHatImageURI

Change a hat's image URI.

```typescript
const result = await hatsClient.changeHatImageURI({
  account,
  hatId,
  newImageURI,
});
```

**Arguments**:
```typescript
{
  account: Account;
  hatId: bigint;
  newImageURI: string;
}
```

- `account` - Viem account to send the transaction from.
- `hatId` - ID of the hat to change image URI for.
- `newImageURI` - New image URI to set.

**Response**:
```typescript
{
  status: 'success' | 'reverted';
  transactionHash: `0x${string}`;
}
```

- `status` - "success" if transaction was successful, "reverted" if transaction reverted.
- `transactionHash` - Transaction's hash.

## changeHatMaxSupply

Change a hat's maximum supply.

```typescript
const result = await hatsClient.changeHatMaxSupply({
  account,
  hatId,
  newMaxSupply,
});
```

**Arguments**:
```typescript
{
  account: Account;
  hatId: bigint;
  newMaxSupply: bigint;
}
```

- `account` - Viem account to send the transaction from.
- `hatId` - ID of the hat to change maximum supply for.
- `newMaxSupply` - New maximum supply to set.

**Response**:
```typescript
{
  status: 'success' | 'reverted';
  transactionHash: `0x${string}`;
}
```

- `status` - "success" if transaction was successful, "reverted" if transaction reverted.
- `transactionHash` - Transaction's hash. 

# Multicall

For any write function, the SDK includes a corresponding call data version that returns the call data information instead of submitting a transaction. These objects can then be aggregated and passed into the `multicall` function in order to batch multiple operations into one transaction.

## multicall

Batch multiple write operations in one transaction.

```typescript
const result = await hatsClient.multicall({
  account,
  calls,
});
```

**Arguments**:
```typescript
{
  account: Account;
  calls: {
    functionName: string;
    callData: Hex;
  }
  [];
}
```

- `account` - Viem account to send the transaction from.
- `calls` - An array of call data objects, each one includes the function name and the call data to pass to the function.

**Response**:
```typescript
{
    status: "success" | "reverted";
    transactionHash: `0x${string}`;
    gasUsed: bigint;
    hatsCreated: bigint[];
    hatsMinted: {
        hatId: bigint;
        wearer: `0x${string}`;
    }[];
    hatsBurned: {
        hatId: bigint;
        wearer: `0x${string}`;
    }[];
    hatStatusChanges: {
        hatId: bigint;
        newStatus: "active" | "inactive";
    }[];
    wearerStandingChanges: {
        hatId: bigint;
        wearer: `0x${string}`;
        newStanding: "good" | "bad";
    }[];
}
```

- `status` - "success" if transaction was successful, "reverted" if transaction reverted.
- `transactionHash` - Transaction's hash.
- `gasUsed` - Amount of gas used in the transaction.
- `hatsCreated` - Hats IDs of any newly created hats.
- `hatsMinted` - For every hat minted, contains an object with the hat ID and the new wearer address.
- `hatsBurned` - For every hat burned, contains an object with the hat ID and the wearer address.
- `hatStatusChanges` - For every hat status change, contains an object with the hat ID and the new status.
- `wearerStandingChanges` - For every wearer standing status change, contains an object with the hat ID, the wearer address and the new standing.

**Example:**

Create a new top-hat, then create one child hat and mint the child hat to a new wearer.

```typescript
const mintTopHatCallData = await hatsClient.mintTopHatCallData({
  target,
  details,
  imageURI,
});

const createHatCallData = await hatsClient.createHatCallData({
  admin,
  details,
  maxSupply,
  eligibility,
  toggle,
  mutable,
  imageURI,
});

const mintHatCallData = await hatsClient.mintHatCallData({
  hatId,
  wearer,
});

const result = await hatsClient.multicall({
  account,
  calls: [mintTopHatCallData, createHatCallData, mintHatCallData],
});
```

## multicallPreFlightCheck

Simulates the multicall function with the provided calls. The function has no return value, will revert on failure, with a custom error.

```typescript
await hatsClient.multicallPreFlightCheck({
  account,
  calls,
});
```

**Arguments**:
```typescript
{
  account: Account;
  calls: {
    functionName: string;
    callData: Hex;
  }
  [];
}
```

- `account` - Viem account to send the transaction from.
- `calls` - An array of call data objects, each one includes the function name and the call data to pass to the function.
```

# Claiming Hats

Hats can be made claimable by using the [Multi Claims Hatter module](https://docs.hatsprotocol.xyz/hats-integrations/hatter-modules/multi-claims-hatter).

The following functions support the claiming functionality enabled by this module.

## accountCanClaim

Check whether an account can claim a given hat.

```typescript
const canClaim = await hatsClient.accountCanClaim({
    hatId,
    account,
});
```

**Arguments**:
```typescript
{
    hatId: bigint;
    account: Address;
}
```

* `hatId` - The hat ID to claim.
* `account` - The claiming account's address.

**Response**:
```typescript
boolean
```

`true` if can claim, `false` otherwise.

### canClaimForAccount

Check whether a hat can be claimed on behalf of a given account.

```typescript
const canClaimFor = await hatsClient.canClaimForAccount({
    hatId,
    account,
});
```

**Arguments**:
```typescript
{
    hatId: bigint;
    account: Address;
}
```

* `hatId` - The hat ID to claim-for.
* `account` - The account address to claim on behalf of.

**Response**:
```typescript
boolean
```

`true` if can claim-for, `false` otherwise.

## claimHat

Claim a hat for the calling account.

```typescript
const claimHatResult = await hatsClient.claimHat({
    account,
    hatId,
});
```

**Arguments**:
```typescript
{
    account: Account | Address;
    hatId: bigint;
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `hatId` - ID of the hat to claim.

**Response**:
```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
}
```

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.

## claimHatFor

Claim a hat on behalf of a chosen account.

```typescript
const claimHatForResult = await hatsClient.claimHatFor({
    account,
    hatId,
    wearer,
});
```

**Arguments**:
```typescript
{
    account: Account | Address;
    hatId: bigint;
    wearer: Address;
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `hatId` - ID of the hat to claim-for.
* `wearer` - Address for which to claim the hat for.

**Response**:
```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
}
```

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.

## multiClaimHatFor

Claim a hat on behalf of multiple accounts.

```typescript
const claimHatForResult = await hatsClient.multiClaimHatFor({
    account,
    hatId,
    wearers,
});
```

**Arguments**:
```typescript
{
    account: Account | Address;
    hatId: bigint;
    wearers: Address[];
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `hatId` - ID of the hat to claim-for.
* `wearers` - Addresses for which to claim the hat for.

**Response**:
```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
}
```

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.
```

# Utilities

## Hat & Tree ID Utils

Following are utility functions to handle various hat & tree ID formats.

### hatIdDecimalToHex

Convert a hat ID from decimal to hex.

```typescript
import { hatIdDecimalToHex } from "@hatsprotocol/sdk-v1-core";

const hatIdHex = hatIdDecimalToHex(hatId);
```

**Arguments**:
```typescript
hatId: bigint
```

`hatId` - Hat ID in decimal format.

**Response**:
```typescript
`0x${string}`
```

Hat ID in a hex format.

### hatIdHexToDecimal

Convert a hat ID from hex to decimal.

```typescript
import { hatIdHexToDecimal } from "@hatsprotocol/sdk-v1-core";

const hatIdDecimal = hatIdHexToDecimal(hatId);
```

**Arguments**:
```typescript
hatId: string
```

`hatId` - Hat ID in hex format.

**Response**:
```typescript
bigint
```

Hat ID in a decimal format.

### treeIdDecimalToHex

Convert a tree ID from decimal to hex. A tree ID is the first 4 bytes in a hat ID.

```typescript
import { treeIdDecimalToHex } from "@hatsprotocol/sdk-v1-core";

const treeIdHex = treeIdDecimalToHex(treeId);
```

**Arguments**:
```typescript
treeId: number
```

`treeId` - Tree ID in decimal format.

**Response**:
```typescript
`0x${string}`
```

Tree ID in a hex format.

### treeIdHexToDecimal

Convert a tree ID from hex to decimal. A tree ID is the first 4 bytes in a hat ID.

```typescript
import { treeIdHexToDecimal } from "@hatsprotocol/sdk-v1-core";

const treeIdDecimal = treeIdHexToDecimal(treeId);
```

**Arguments**:
```typescript
treeId: string
```

`treeId` - Tree ID in hex format.

**Response**:
```typescript
number
```

Tree ID in a decimal format.

### treeIdToTopHatId

Convert a tree ID to its top-hat ID. A tree ID is the first 4 bytes in a hat ID.

```typescript
import { treeIdToTopHatId } from "@hatsprotocol/sdk-v1-core";

const tophatId = treeIdToTopHatId(treeId);
```

**Arguments**:
```typescript
treeId: number
```

`treeId` - Tree ID in decimal format.

**Response**:
```typescript
bigint
```

Top-hat ID in decimal format.

### hatIdToTreeId

Convert a hat ID to its tree ID. A tree ID is the first 4 bytes in a hat ID.

```typescript
import { hatIdToTreeId } from "@hatsprotocol/sdk-v1-core";

const treeId = hatIdToTreeId(hatId);
```

**Arguments**:
```typescript
hatId: bigint
```

`hatId` - Hat ID in decimal format.

**Response**:
```typescript
number
```

Tree ID of the hat, in a decimal format.

### hatIdDecimalToIp

The IP format may be used as a "pretty" hat ID format for presenting.

For example, a hat with a hex ID of:
`0x00000001000a0002000000000000000000000000000000000000000000000000` will have an IP format of 1.10.2 - Each level is separated by a dot and presented as a decimal number, excluding zeros.

```typescript
import { hatIdDecimalToIp } from "@hatsprotocol/sdk-v1-core";

const hatIdIp = hatIdDecimalToIp(hatId);
```

**Arguments**:
```typescript
hatId: bigint
```

`hatId` - Hat ID in decimal format.

**Response**:
```typescript
string
```

Hat ID in IP format.

### hatIdIpToDecimal

Convert a hat ID from an IP format, to a decimal format.

```typescript
import { hatIdIpToDecimal } from "@hatsprotocol/sdk-v1-core";

const hatIdDecimal = hatIdIpToDecimal(hatId);
```

**Arguments**:
```typescript
hatId: string
```

`hatId` - Hat ID in IP format.

**Response**:
```typescript
bigint
```

Hat ID in decimal format.

## Constants

Following are Hats-specific exported constant values.

```typescript
import {   
  HATS_V1, // Hats-Protocol v1 contract address
  MAX_LEVELS, // Max levels on a Hats tree
  MAX_LEVEL_HATS, // Max amount of hats on each level (excluding level 0)
  ZERO_ID, // The zero Hat ID in hex format 
  FALLBACK_ADDRESS, // The fallback address for eligibility and toggle 
} from "@hatsprotocol/sdk-v1-core";
```

# Subgraph

## Overview

The SDK is an open source JavaScript client, providing utility functions for fetching data from the Hats Protocol Subgraphs and is designed to work both in the browser and in Node.js.

# Getting Started

## Install

yarn:
```bash
yarn add @hatsprotocol/sdk-v1-subgraph
```

npm:
```bash
npm install @hatsprotocol/sdk-v1-subgraph
```

## HatsSubgraphClient Initialization

Import and initialize HatsSubgraphClient.

Optionally configure the Subgraph endpoints to use, or use the default ones.

```typescript
import { HatsSubgraphClient } from "@hatsprotocol/sdk-v1-subgraph";

const hatsSubgraphClient = new HatsSubgraphClient({
    config
});
```

**Arguments**:
```typescript
{ config?: EndpointsConfig }
```

* `config` - Optional subgraph endpoints configuration. If not provided, then the default, un-gated development endpoints will be used. See the `EndpointsConfig` type for more details.
```

# Fetching Hats

## getHat

Get a Hat by its ID.

```typescript
const hat = await hatsSubgraphClient.getHat({
    chainId,
    hatId,
    props,
});
```

**Arguments**:
```typescript
{
    chainId: number;
    hatId: bigint;
    props: HatPropsConfig;
}
```

* `chainId` - ID of the chain to fetch from.
* `hatId` - ID of the Hat to fetch.
* `props` - Hat's properties to fetch, including the ones of nested objects. Check the HatPropsConfig type for the available properties and query filters.

**Response**:
```typescript
Hat
```

A Hat object, containing the chosen properties.

**Example**:
```typescript
const res = await client.getHat({
  chainId: 10, // optimism
  hatId: BigInt(
    "0x0000000100020001000100000000000000000000000000000000000000000000"
  ),
  props: {
    maxSupply: true, // get the maximum amount of wearers for the hat 
    wearers: { // get the hat's wearers 
      props: {}, // for each wearer, include only its ID (address)
    },
    events: { // get the hat's events
      props: {
        transactionID: true, // for each event, include the transaction ID
      },
      filters: {
        first: 10, // fetch only the latest 10 events
      },
    },
  },
});
```

## getHatsByIds

Get Hats by their IDs.

```typescript
const hats = await hatsSubgraphClient.getHatsByIds({
    chainId,
    hatIds,
    props,
});
```

**Arguments**:
```typescript
{
    chainId: number;
    hatIds: bigint[];
    props: HatPropsConfig;
}
```

* `chainId` - ID of the chain to fetch from.
* `hatIds` - IDs of the Hats to fetch.
* `props` - Hat's properties to fetch, including the ones of nested objects. Check the HatPropsConfig type for the available properties and query filters.

**Response**:
```typescript
Hat[]
```

An array of [Hat objects](types.md#hat), containing the chosen properties.

_**Example**_:

```typescript
const res = await client.getHatsByIds({
  chainId: 10, // optimism
  hatIds: [
    BigInt("0x0000000100020001000100000000000000000000000000000000000000000000"),
    BigInt("0x0000000100020001000000000000000000000000000000000000000000000000"),
  ],
  props: {
    wearers: { // get each hat's wearers
      props: { 
        currentHats: { // for each wearer, get its hats
          props: {}, // for each hat, include only its ID
        },
      },
    },
  },
});
```

# Fetching Wearers

## getWearer

Get a Wearer by its address.

```typescript
const wearer = await hatsSubgraphClient.getWearer({
  chainId,
  wearerAddress,
  props,
});
```

**Arguments**:

```typescript
{
  chainId: number;
  wearerAddress: `0x${string}`;
  props: WearerPropsConfig;
}
```

- `chainId` - ID of the chain to fetch from.
- `wearerAddress` - Address of the Wearer to fetch.
- `props` - Wearer's properties to fetch, including the ones of nested objects. Check the WearerPropsConfig type for the available properties and query filters.

**Response**:

```typescript
Wearer;
```

A Wearer object, containing the chosen properties.

**Example**:

```typescript
const res = await client.getWearer({
  chainId: 10,
  wearerAddress: '0x...',
  props: {
    hats: {
      // get the wearer's hats
      props: {}, // for each hat, include only its ID
      filters: {
        first: 10, // fetch only the latest 10 hats
      },
    },
    events: {
      // get the wearer's events
      props: {
        transactionID: true, // for each event, include the transaction ID
      },
      filters: {
        first: 10, // fetch only the latest 10 events
      },
    },
  },
});
```

## getWearersOfHatPaginated

Get Wearers of a Hat in a paginated manner.

```typescript
const wearers = await hatsSubgraphClient.getWearersOfHatPaginated({
  chainId,
  hatId,
  props,
  page,
  perPage,
});
```

**Arguments**:

```typescript
{
  chainId: number;
  hatId: bigint;
  props: WearerPropsConfig;
  page: number;
  perPage: number;
}
```

- `chainId` - ID of the chain to fetch from.
- `hatId` - ID of the Hat to fetch wearers for.
- `props` - Wearer's properties to fetch, including the ones of nested objects. Check the WearerPropsConfig type for the available properties and query filters.
- `page` - Page number to fetch.
- `perPage` - Amount of items per page.

**Response**:

```typescript
{
    items: Wearer[];
    totalItems: number;
    totalPages: number;
}
```

- `items` - Array of Wearer objects, containing the chosen properties.
- `totalItems` - Total amount of wearers.
- `totalPages` - Total amount of pages.

**Example**:

```typescript
// get the first 10 wearers of a given hat.
// include only the wearer's ID (address) in the result
const res = await client.getWearersOfHatPaginated({
  chainId: 10,
  hatId: BigInt(
    '0x0000000100020001000100000000000000000000000000000000000000000000'
  ),
  props: {},
  page: 1,
  perPage: 10,
});
```

# Fetching Trees

## getTree

Get a Tree by its ID.

```typescript
const tree = await hatsSubgraphClient.getTree({
    chainId,
    treeId,
    props,
});
```

**Arguments**:
```typescript
{
    chainId: number;
    treeId: number;
    props: TreePropsConfig;
}
```

* `chainId` - ID of the chain to fetch from.
* `treeId` - ID of the Tree to fetch (Tree's top-hat domain - first 4 bytes of the top-hat ID).
* `props` - Tree's properties to fetch, including the ones of nested objects. Check the TreePropsConfig type for the available properties and query filters.

**Response**:
```typescript
Tree
```

A Tree object, containing the chosen properties.

**Example**:
```typescript
// get a tree's top-hat
const res = await client.getTree({
  chainId: 10, // optimism
  treeId: 1, 
  props: {
    hats: { // get the tree's hats
      props: {}, // for each hat, include only its ID
      filters: { first: 1 }, // fetch only the first hat (the top-hat)
    },
  },
});
```

## getTreesByIds

Get Trees by their IDs.

```typescript
const trees = await hatsSubgraphClient.getTreesByIds({
    chainId,
    treeIds,
    props,
});
```

**Arguments**:
```typescript
{
    chainId: number;
    treeIds: number[];
    props: TreePropsConfig;
}
```

* `chainId` - ID of the chain to fetch from.
* `treeIds` - IDs of the Trees to fetch (Tree's top-hat domain - first 4 bytes of the top-hat ID).
* `props` - Tree's properties to fetch, including the ones of nested objects. Check the TreePropsConfig type for the available properties and query filters.

**Response**:
```typescript
Tree[]
```

An array of Tree objects, containing the chosen properties.

**Example**:
```typescript
const res = await client.getTreesByIds({
  chainId: 10, // optimism
  treeIds: [1, 2],
  props: {
    hats: { // for each tree, fetch its hats
      props: {
        status: true, // for each hat, include its status (active/inactive)
      },
      filters: { first: 200 }, // fetch only the first 200 hats
    },
  },
});
```

## getTreesPaginated

Get Trees in a paginated manner.

```typescript
const trees = await hatsSubgraphClient.getTreesPaginated({
    chainId,
    props,
    page,
    perPage,
});
```

**Arguments**:
```typescript
{
    chainId: number;
    props: TreePropsConfig;
    page: number;
    perPage: number;
}
```

* `chainId` - ID of the chain to fetch from.
* `props` - Tree's properties to fetch, including the ones of nested objects. Check the TreePropsConfig type for the available properties and query filters.
* `page` - Page number to fetch.
* `perPage` - Amount of Trees to fetch in each page.

**Response**:
```typescript
Tree[]
```

An array of Tree objects, containing the chosen properties.

**Example**:
```typescript
const res = await client.getTreesPaginated({
  chainId: 10, // optimism
  props: {
    hats: { // for each tree, get its hats
      props: {}, // for each hat, include only its ID 
      filters: { first: 1 }, // fetch only the first hat of every tree (the top-hat)
    },
  },
  page: 3, // get the third page
  perPage: 10, // each page contains 10 trees
});


```

# Misc

## searchTreesHatsWearers

Search for a Hat, Tree or Wearer by ID.

```typescript
const res = await hatsSubgraphClient.searchTreesHatsWearers({
    chainId,
    search,
    treeProps,
    hatProps,
    wearerProps,
});
```

**Arguments**:

```typescript
{
    chainId: number;
    search: string;
    treeProps: TreePropsConfig;
    hatProps: HatPropsConfig;
    wearerProps: WearerPropsConfig;
}
```

* `chainId` - ID of the chain to fetch from.
* `search` - ID to search for (Hat ID or pretty ID, Tree ID or Wearer address).
* `treeProps` - Tree's properties to fetch, including the ones of nested objects. Check the TreePropsConfig type for the available properties and query filters.
* `hatProps` - Hat's properties to fetch, including the ones of nested objects. Check the HatPropsConfig type for the available properties and query filters.
* `wearerProps` - Wearer's properties to fetch, including the ones of nested objects. Check the WearerPropsConfig type for the available properties and query filters.

**Response**:

```typescript
{ trees: Tree[]; hats: Hat[]; wearers: Wearer[] }
```

An object containing the search result.

**Example:**

```typescript
// search for a given hat, tree or wearer.
// include only the object's ID in the reuslt 
const res = await client.searchTreesHatsWearers({
  chainId: 10,
  search: "0x0000000100020001000100000000000000000000000000000000000000000000",
  treeProps: {},
  hatProps: {},
  wearerProps: {},
});
```

# Types

## Hat Types

### Hat

```typescript
interface Hat {
  id: `0x${string}`; // Hat ID
  prettyId?: string; // pretty ID format
  status?: boolean; // 'true' if active, 'false' otherwise
  createdAt?: string | null; // timestamp of hat creation, null if not created yet
  details?: string; // Hat's details field
  maxSupply?: string; // max amount of wearers
  eligibility?: `0x${string}`; // eligibility address
  toggle?: `0x${string}`; // toggle address
  mutable?: boolean; // 'true' if mutable, 'false' otherwise
  imageUri?: string; // Hat's image URI
  levelAtLocalTree?: number; // Hat's level at its local tree (not including linked trees)
  currentSupply?: string; // current amount of hat wearers
  tree?: Tree; // Tree which contains the Hat
  wearers?: Wearer[]; // Hat's Wearers
  badStandings?: Wearer[]; // Hat's Wearers in bad standing
  admin?: Hat; // Hat's admin Hat
  subHats?: Hat[]; // Hat's children Hats
  linkRequestFromTree?: Tree[]; // Link requests from Trees
  linkedTrees?: Tree[]; // Trees linked to the Hat
  claimableBy?: ClaimsHatter[]; // Claims Hatters that the Hat is made claimable by
  claimableForBy?: ClaimsHatter[]; // Claims Hatters that the Hat is made claimable for by
  events?: HatsEvent[]; // Hat's events
}
```

### HatPropsConfig

Query configuration for a Hat's properties.

The Hat's ID property is required and thus is not included in the config. The rest of the properties are optional.

* To choose Scalar properties (non-object), include their key with a value of `true`.
* To choose an Object property, include its key with a value compatible with the object's config type:
  * For single-object properties (e.g. `tree`), the config type includes the object's available properties without filters.
  * For multi-object properties (e.g. `wearers`), the config type includes both the object's available properties and optional filters (currently supports only the 'first' filter).

```typescript
interface HatPropsConfig {
  prettyId?: boolean;
  status?: boolean;
  createdAt?: boolean;
  details?: boolean;
  maxSupply?: boolean;
  eligibility?: boolean;
  toggle?: boolean;
  mutable?: boolean;
  imageUri?: boolean;
  levelAtLocalTree?: boolean;
  currentSupply?: boolean;
  tree?: TreePropsConfig;
  wearers?: WearersConfig;
  badStandings?: WearersConfig;
  admin?: HatPropsConfig;
  subHats?: HatsConfig;
  linkRequestFromTree?: TreesConfig;
  linkedTrees?: TreesConfig;
  claimableBy?: ClaimsHattersConfig;
  claimableForBy?: ClaimsHattersConfig;
  events?: HatsEventsConfig;
}
```

### HatsConfig

Query configuration for a multi Hats property, i.e. a property that returns multiple Hats.

```typescript
interface HatsConfig {
  props: HatPropsConfig; // properties to include in each hat
  filters?: { // filters to apply on the property query
    first?: number; // fetch only the 'first' amount of hats
  };
}
```

## Wearer Types

### Wearer

```typescript
interface Wearer {
  id: `0x${string}`; // Wearer's address
  currentHats?: Hat[]; // Wearer's current Hats
  mintEvent?: HatsEvent[]; // Hat mint events for the Wearer
  burnEvent?: HatsEvent[]; // Hat burn events for the Wearer
}
```

### WearerPropsConfig

Query configuration for a Wearer's properties.

The Wearer's ID property is required and thus is not included in the config. The rest of the properties are optional.

* To choose Scalar properties (non-object), include their key with a value of `true`.
* To choose an Object property, include its key with a value compatible with the object's config type:
  * For single-object properties (e.g. the `tree` property of a Hat), the config type includes the object's available properties.
  * For multi-object properties (e.g. `currentHats`), the config type includes both the object's available properties and optional filters (currently supports only the 'first' filter).

```typescript
interface WearerPropsConfig {
  currentHats?: HatsConfig;
  mintEvent?: HatsEventsConfig;
  burnEvent?: HatsEventsConfig;
}
```

### WearersConfig

Query configuration for a multi Wearers property, i.e. a property that returns multiple Wearers.

```typescript
interface WearerPropsConfig {
  props: WearerPropsConfig; // properties to include in each wearer
  filters?: { // filters to apply on the property query
    first?: number; // fetch only the 'first' amount of wearers
  };
}
```

## Tree Types

### Tree

```typescript
interface Tree {
  id: `0x${string}`; // Tree ID (Tree's top-hat domain - first 4 bytes of the top-hat ID)
  hats?: Hat[]; // Tree's Hats
  childOfTree?: Tree; // if linked, the Tree which this Tree is linked to
  parentOfTrees?: Tree[]; // Trees which are linked to this Tree
  linkedToHat?: Hat; // if linked, the Hat which this Tree is linked to
  linkRequestFromTree?: Tree[]; // Trees with a linkage request to this Tree
  requestedLinkToTree?: Tree; // Tree which this Tree has a linkage request to
  requestedLinkToHat?: Hat; // Hat which this Tree has a linkage request to
  events?: HatsEvent[]; // Tree's events
}
```

### TreePropsConfig

Query configuration for a Tree's properties.

The Tree's ID property is required and thus is not included in the config. The rest of the properties are optional.

* To choose Scalar properties (non-object), include their key with a value of `true`.
* To choose an Object property, include its key with a value compatible with the object's config type:
  * For single-object properties (e.g. `childOfTree`), the config type includes the object's available properties.
  * For multi-object properties (e.g. `hats`), the config type includes both the object's available properties and optional filters (currently supports only the 'first' filter).

```typescript
interface TreePropsConfig {
  hats?: HatsConfig;
  childOfTree?: TreePropsConfig;
  parentOfTrees?: TreesConfig;
  linkedToHat?: HatPropsConfig;
  linkRequestFromTree?: TreesConfig;
  requestedLinkToTree?: TreePropsConfig;
  requestedLinkToHat?: HatPropsConfig;
  events?: HatsEventsConfig;
}
```

### TreesConfig

Query configuration for a multi Trees property, i.e. a property that returns multiple Trees.

```typescript
interface TreePropsConfig {
  props: TreePropsConfig; // properties to include in each tree
  filters?: { // filters to apply on the property query
    first?: number; // fetch only the 'first' amount of trees
  };
}
```

## Event Types

### HatsEventBase

Base type, which contains the common properties of Hats Events, and which is then extended by each specific event.

```typescript
interface HatsEventBase {
  id: string; // Event's ID
  timestamp?: bigint; // Event's timestamp
  blockNumber?: number; // Event's block number
  transactionID?: string; // transaction ID which the Event was emitted in
  hat?: Hat; // Hat that relates to the Event
  tree?: Tree; // Tree that relates to the Event
}
```

### HatsEventPropsConfig

Query configuration for the basic properties of a Hats Event.

The HatsEvent's ID property is required and thus is not included in the config. The rest of the properties are optional.

To choose Scalar properties (non-object), include their key with a value of `true`. To choose an Object property, include its key with a value compatible with the object's config.

```typescript
interface HatsEventConfig {
  timestamp?: boolean;
  blockNumber?: boolean;
  transactionID?: boolean;
  hat?: HatPropsConfig;
  tree?: HatPropsConfig;
}
```

Following are the various Hats Events, emitted from Hats-Protocol in response to various actions.

Fetched events will include the event's base properties, as well as the additional properties that are included in each specific event, according to its type.

### HatCreatedEvent

```typescript
interface HatCreatedEvent extends HatsEventBase {
  __typename: "HatCreatedEvent";
  hatDetails: string;
  hatMaxSupply: `0x${string}`;
  hatEligibility: `0x${string}`;
  hatToggle: string;
  hatMutable: boolean;
  hatImageUri: string;
}
```

### HatMintedEvent

```typescript
interface HatMintedEvent extends HatsEventBase {
  __typename: "HatMintedEvent";
  wearer: {
    id: `0x${string}`;
  };
  operator: `0x${string}`;
}
```

### HatBurnedEvent

```typescript
interface HatBurnedEvent extends HatsEventBase {
  __typename: "HatBurnedEvent";
  wearer: {
    id: `0x${string}`;
  };
  operator: `0x${string}`;
}
```

### HatMutabilityChangedEvent

```typescript
interface HatMutabilityChangedEvent extends HatsEventBase {
  __typename: "HatMutabilityChangedEvent";
}
```

### HatStatusChangedEvent

```typescript
interface HatStatusChangedEvent extends HatsEventBase {
  __typename: "HatStatusChangedEvent";
  hatNewStatus: boolean;
}
```

### HatDetailsChangedEvent

```typescript
interface HatDetailsChangedEvent extends HatsEventBase {
  __typename: "HatDetailsChangedEvent";
  hatNewDetails: string;
}
```

### HatEligibilityChangedEvent

```typescript
interface HatEligibilityChangedEvent extends HatsEventBase {
  __typename: "HatEligibilityChangedEvent";
  hatNewEligibility: `0x${string}`;
}
```

### HatToggleChangedEvent

```typescript
interface HatToggleChangedEvent extends HatsEventBase {
  __typename: "HatToggleChangedEvent";
  hatNewToggle: `0x${string}`;
}
```

### HatMaxSupplyChangedEvent

```typescript
interface HatMaxSupplyChangedEvent extends HatsEventBase {
  __typename: "HatMaxSupplyChangedEvent";
  hatNewMaxSupply: string;
}
```

### HatImageURIChangedEvent

```typescript
interface HatImageURIChangedEvent extends HatsEventBase {
  __typename: "HatImageURIChangedEvent";
  hatNewImageURI: string;
}
```

### TopHatLinkRequestedEvent

```typescript
interface TopHatLinkRequestedEvent extends HatsEventBase {
  __typename: "TopHatLinkRequestedEvent";
  newAdmin: `0x${string}`;
}
```

### TopHatLinkedEvent

```typescript
interface TopHatLinkedEvent extends HatsEventBase {
  __typename: "TopHatLinkedEvent";
  newAdmin: `0x${string}`;
}
```

### WearerStandingChangedEvent

```typescript
interface WearerStandingChangedEvent extends HatsEventBase {
  __typename: "WearerStandingChangedEvent";
  wearer: {
    id: `0x${string}`;
  };
  wearerStanding: boolean;
}
```

### HatsEvent

```typescript
type HatsEvent =
  | HatCreatedEvent
  | HatMintedEvent
  | HatBurnedEvent
  | HatMutabilityChangedEvent
  | HatStatusChangedEvent
  | HatDetailsChangedEvent
  | HatEligibilityChangedEvent
  | HatToggleChangedEvent
  | HatMaxSupplyChangedEvent
  | HatImageURIChangedEvent
  | TopHatLinkRequestedEvent
  | TopHatLinkedEvent
  | WearerStandingChangedEvent;
```

## Claims Hatter Types

### ClaimsHatter

```typescript
interface ClaimsHatter {
  id: string; // ClaimsHatter's ID
  claimableHats?: Hat[]; // Hats made claimable by this Hatter
  claimableForHats?: Hat[]; // Hats made 'claimable for' by this Hatter 
}
```

### ClaimsHatterPropsConfig

Query configuration for a ClaimsHatter's properties.

The ClaimsHatter's ID property is required and thus is not included in the config. The rest of the properties are optional.

```typescript
interface ClaimsHatterPropsConfig {
  claimableHats?: HatsConfig;
  claimableForHats?: HatsConfig;
}
```

### ClaimsHattersConfig

Query configuration for a multi ClaimsHatters property, e.g. a property that returns multiple Claims Hatters.

```typescript
interface ClaimsHattersConfig {
  props: ClaimsHatterPropsConfig; // properties to include in each claims hatter
  filters?: { // filters to apply on the property query
    first?: number; // fetch only the 'first' amount of hatters
  };
}
```

## More

### EndpointsConfig

Subgraph endpoints configuration, optionally provided at the client's creation.

```typescript
interface EndpointsConfig {
  [chainId: number]: { endpoint: string };
}
```

# ðŸŽ© Hat Details SDK

## Overview

In Hats Protocol, each hat includes a details field, which is used for arbitrary metadata about the hat, such as a name, description, and other properties like authorities and responsibilities associated with the hat.

A common way to use this field is to store the data on IPFS as a JSON object, and set the hat's details field with the object's CID (Content Identifier). This method allows to add rich metadata about a hat, while keeping the gas costs minimal.

This package provides utility function to handle hats details, by both pinning metadata JSON objects to IPFS and reading from it.

It was designed to work both in the browser and in Node.js.

# Getting Started

## Overview

The package supports storing and reading a hat's metadata from IPFS.

Data is stored in a JSON format, and follows a custom schema which is passed by the user at the client's initialization. By using a schema for the data, we're able to validate that the data is compatible with an expected format.

The package uses the [Zod](https://zod.dev/) library for the schema definition and validation. The schema is also used for type inference, providing type-safety for its users.

## Install

yarn:
```bash
yarn add @hatsprotocol/details-sdk zod
```

npm:
```bash
npm install @hatsprotocol/details-sdk zod
```

## HatsDetailsClient Initialization

A HatsDetailsClient instance is initialized with an IPFS provider (currently only [Pinata](https://www.pinata.cloud/) is supported) and a schema, defined with the [Zod](https://zod.dev/) library.

### Choose which schema to use

#### Option 1 - use the default schema

If the client is initialized without a custom schema, then the default schema will be used. This schema is compatible with the Hats App, meaning that this app will properly display hats with this type of details.

```typescript
import { HatsDetailsClient } from "@hatsprotocol/details-sdk";

let hatsDetailsClient: HatsDetailsClient;
hatsDetailsClient = new HatsDetailsClient({
      provider: "pinata",
      pinata: {
        pinningKey: process.env.PINATA_JWT as string,
      },
});
```

Here's the default schema:

```typescript
z.object({
  type: z.literal("1.0"),
  data: z.object({
    name: z.string(),
    description: z.string().optional(),
    responsabilities: z
      .array(
        z.object({
          label: z.string(),
          description: z.string().optional(),
          link: z.string().optional(),
          imageUrl: z.string().optional(),
        })
      )
      .optional(),
    authorities: z
      .array(
        z.object({
          label: z.string(),
          description: z.string().optional(),
          link: z.string().optional(),
          imageUrl: z.string().optional(),
          gate: z.string().optional(),
        })
      )
      .optional(),
  }),
});
```

The corresponding type for this schema is:

```typescript
{
    type: "1.0";
    data: {
        name: string;
        description?: string | undefined;
        responsabilities?: {
            label: string;
            description?: string | undefined;
            link?: string | undefined;
            imageUrl?: string | undefined;
        }[] | undefined;
        authorities?: {
            label: string;
            description?: string | undefined;
            link?: string | undefined;
            imageUrl?: string | undefined;
            gate?: string | undefined;
        }[] | undefined;
    };
}
```

#### Option 2 - use a custom schema

You can define a custom schema for the client, for example:

```typescript
import * as z from "zod";

const schema = z.object({
  name: z.string(),
  description: z.string(),
});

let hatsDetailsClient: HatsDetailsClient<typeof schema>;
hatsDetailsClient = new HatsDetailsClient({
      schema,
      provider: "pinata",
      pinata: {
        pinningKey: process.env.PINATA_JWT as string,
      },
});
```

### Set up the Pinata provider

The client is initialized with an IPFS provider that will be used for storing and reading to/from IPFS. Currently, Pinata is the only supported provider and is initialized with the following properties:

```typescript
{
   pinningKey: string;
   gateway?: string;
   gatewayKey?: string;
}
```

* `pinningKey` - this as a JWT that's used for pinning data, and is required at the client's initialization.
* `gateway` - a dedicated gateway URL, that's provided by Pinata and is used to read IPFS data. This property is optional. If not provided, then the default gateway that's provided by https://ipfs.io will be used.
* `gatewayKey` - optional key that is used to secure dedicated Pinata gateways. If provided along with a gateway, then the key will be used for fetching data.

# Usage

Once initialized, the HatsDetailsClient can be used for reading and storing data from/to IPFS, in a predetermined format.

## Store

Use the following function in order to store/pin data to IPFS.

The data is expected to be compatible with the provided schema, otherwise an error will be thrown. If data was successfully pinned, its CID (content identifier) will be returned. This can then be used for reading the data back from IPFS.

```typescript
const cid = await hatsDetailsClient.pin({
    type: "1.0",
    data: {
        name: "Hat",
        description: "This is a hat",
    },
});
```

## Read

Read data from IPFS.

```typescript
const data = await hatsDetailsClientDefaultSchema.get(
    "QmcSopxmw5rMEEEU8NmGGQ2mbHJ293CGEiQ4r4w4jEECVy"
);
```

The returned data has the following type:

```typescript
{
    parsedData: z.infer<T> | null;
    rawData: unknown | null;
    error: { message: string } | null;
}
```

* If data was successfully fetched and is compatible with the client's schema, then the parsed data will be in the `parsedData` field, while the `rawData` and `error` fields will be `null`.
* If data was successfully fetched but is not compatible with the client's schema, then the data will be in the `rawData` field, while the `data` and `error` fields will be `null`.
* If an error occurred, then the `data` and `rawData` fields will be `null`, and the `error` field will contain an object with a `message` field.

# ðŸ”­ v1 Subgraphs

Check the [GitHub repository](https://github.com/Hats-Protocol/subgraph/tree/main) README for example queries and general documentation and/or our [Subgraph SDK](v1-sdk/subgraph/).

**Hosted Endpoints (Free)**:

* [Ethereum (mainnet)](https://api.studio.thegraph.com/query/55784/hats-v1-ethereum/version/latest)
* [Arbitrum](https://api.studio.thegraph.com/query/55784/hats-v1-arbitrum/version/latest)
* [Base](https://api.studio.thegraph.com/query/55784/hats-v1-base/version/latest)
* [Celo](https://api.studio.thegraph.com/query/55784/hats-v1-celo/version/latest)
* [Gnosis](https://api.studio.thegraph.com/query/55784/hats-v1-gnosis-chain/version/latest)
* [Optimism](https://api.studio.thegraph.com/query/55784/hats-v1-optimism/version/latest)
* [Polygon](https://api.studio.thegraph.com/query/55784/hats-v1-polygon/version/latest)
* [Sepolia](https://api.studio.thegraph.com/query/55784/hats-v1-sepolia/version/latest)

**The Graph Network Endpoints:**

* [Ethereum (mainnet)](https://thegraph.com/explorer/subgraphs/AtrhAMCcVfPbmejxTez3G59Kdfu5tMFoiPsTUjdCzpKx?view=Overview&chain=arbitrum-one)
* [Arbitrum](https://thegraph.com/explorer/subgraphs/4CiXQPjzKshBbyK2dgJiknTNWcj8cGUJsopTsXfm5HEk?view=Overview&chain=arbitrum-one)
* [Celo](https://thegraph.com/explorer/subgraphs/GpKseh3Z4nX2X8W5HjQPp5hpSSxPxsaQ3t1KpEjhvz7t?view=Overview&chain=arbitrum-one)
* [Gnosis](https://thegraph.com/explorer/subgraphs/2VPQUuAeS9Xy8VtinpjHRJEMnZS1sqzFQyCHAys1wb5n?view=Overview&chain=arbitrum-one)
* [Optimism](https://thegraph.com/explorer/subgraphs/9nmXXk3ysDVY4sFygWQNQknwiJLCPnrUNzDRw8bxw61q?view=Overview&chain=arbitrum-one)
* [Polygon](https://thegraph.com/explorer/subgraphs/7MxsRb1p4UQNET8AgrWd93h3GUgeQ7NWrk5SHLEPCxBP?view=Overview&chain=arbitrum-one)

# ðŸ§© Hats Modules

A Hats Module is any contract that serves as an Eligibility module, a Toggle module, and/or a Hatter contract. Modules customize, automate, and extend the behavior of Hats Protocol, and can also serve as adapters or integration points with other protocols and applications.

In a sense, modules are the lifeblood of Hats Protocol. The design space is wide open, ready to be filled with all the possible building blocks of human organization and coordination.

# ðŸ”Œ Modules SDK

## Overview

The Modules SDK is an open source JavaScript client that provides core functionality for using existing eligibility, toggle, and hatter Modules. It is designed to work both in the browser and in Node.js.

The available Modules are included in the Modules registry - an open source registry (currently hosted on GitHub) which contains the various Hats Modules available to use.

# Getting Started

## _Install_

yarn:

```bash
yarn add @hatsprotocol/modules-sdk viem
```

npm:

```bash
npm install @hatsprotocol/modules-sdk viem
```

The SDK uses Viem in order to interact with the various chains and includes it as a peer dependency.

## _HatsModulesClient Initialization_

Import and initialize HatsModulesClient:

```typescript
import { HatsModulesClient } from "@hatsprotocol/modules-sdk";

const hatsModulesClient = new HatsModulesClient({
    publicClient,
    walletClient,
});
```

_**Arguments**_:

```typescript
{
    publicClient: PublicClient;
    walletClient: WalletClient;
}
```

* `publicClient` - A Viem Public Client, used for onchain read operations.
* `walletClient` - A Viem Wallet Client, used for onchain write operations.&#x20;

## _Prepare_

The `prepare` function fetches from the [modules registry](https://github.com/Hats-Protocol/modules-registry). This step is necessary in order to be able to use the client. Additionally, the function accepts an optional `registry` input , in order to support user's caching. If provided, then the client will use the given modules instead of fetching from the registry.

```typescript
await hatsModulesClient.prepare();
```

_**Arguments**_:

```typescript
registry?: Registry
```

`registry` - Optional [registry object](types.md#registry) to use, instead of fetching from the current registry.

# Get Available Modules

The following functions are used in order to get available modules, as exist in the [Modules Registry](../hats-modules/building-hats-modules/modules-registry.md).

See the Module type [here](../hats-modules/modules-sdk/types.md#module).

## getModules

Get all available modules, optionally use a filter function in order to retrieve only a subset of the modules.

```typescript
const modules = hatsModulesClient.getAllModules();
```

_**Arguments**_:

```typescript
filter?: (module: Module) => boolean
```

An optional filter function. For each [Module](../hats-modules/modules-sdk/types.md#module), should return `true` if the module should be included, `false` otherwise.

_**Response**_:

```typescript
{ [id: string]: Module }
```

An object that maps between module IDs and the corresponding module objects. A module ID is its implementation address.

## getModuleById

Get a module object by its ID.

```typescript
const module = hatsModulesClient.getModuleById(moduleId);
```

_**Arguments**_:

```typescript
string
```

Module's ID (implementation address).

_**Response**_:

<pre class="language-typescript"><code class="lang-typescript"><strong>Module | undefined
</strong></code></pre>

The module that matches the provided ID, or `undefined` in case no matching module was found.

### getModuleByImplementation

Get a module object by its implementation address.

```typescript
const module = hatsModulesClient.getModuleByImplementation(address);
```

_**Arguments**_:

```typescript
`0x${string}`
```

Module's implementation address.

_**Response**_:

<pre class="language-typescript"><code class="lang-typescript"><strong>Module | undefined
</strong></code></pre>

The module that matches the provided address, or `undefined` in case no matching module was found.

### getModuleByInstance

Get the module object of an instance.

```typescript
const module = await hatsModulesClient.getModuleByInstance(address);
```

_**Arguments**_:

```typescript
`0x${string}`
```

Module's instance address.

_**Response**_:

<pre class="language-typescript"><code class="lang-typescript"><strong>Module | undefined
</strong></code></pre>

The module that matches the provided address, or `undefined` in case no matching module was found.

### getModulesByInstances

Get the module objects of instances.

```typescript
const modules = await hatsModulesClient.getModulesByInstances(addresses);
```

_**Arguments**_:

```typescript
`0x${string}`[]
```

Addresses of the module instances.

_**Response**_:

<pre class="language-typescript"><code class="lang-typescript"><strong>(Module | undefined)[]
</strong></code></pre>

The modules matching the provided addresses. For every address that is not an instance of a registry module, the corresponding return value in the array will be `undefined`.

# Create New Instance/s

## createNewInstance

Create a new module instance.

```typescript
const createInstanceResult = await hatsModulesClient.createNewInstance({
    account,
    moduleId,
    hatId,
    immutableArgs,
    mutableArgs,
    saltNonce,
});
```

_**Arguments**_:

```typescript
{
    account: Account | Address;
    moduleId: string;
    hatId: bigint;
    immutableArgs: unknown[];
    mutableArgs: unknown[];
    saltNonce?: bigint;
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `moduleId` - The module ID (implementation address).
* `hatId` - The hat ID for which the module is created.
* `immutableArgs` - The module's immutable args. The arguments should be in the same order as in the [Module](types.md#module) object.
* `mutableArgs` - The module's mutable args. The arguments should be in the same order as in the [Module](types.md#module) object.
* `saltNonce` - Optional salt nonce to use. If not provided, will be randomly generated.

_**Response**_:

```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
  newInstance: `0x${string}`;
}
```

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.
* `newInstance` - In case of success, the address of the new module instance.

## batchCreateNewInstances

Batch create new module instances.

Each module will be created according to the provided parameters, on the same corresponding array index.

```typescript
const createInstancesResult = await hatsModulesClient.batchCreateNewInstances({
    account,
    moduleIds,
    hatIds,
    immutableArgsArray,
    mutableArgsArray,
    saltNonces
});
```

_**Arguments**_:

```typescript
{
    account: Account | Address;
    moduleIds: string[];
    hatIds: bigint[];
    immutableArgsArray: unknown[][];
    mutableArgsArray: unknown[][];
    saltNonces?: bigint[]; 
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `moduleIds` - The module IDs (implementation address).
* `hatIds` - The hat IDs for which the modules are created.
* `immutableArgsArray` - Each module's immutable arguments. For each module, the arguments should be in the same order as in the [Module](types.md#module) object.
* `mutableArgsArray` - Each module's mutable arguments. For each module, the arguments should be in the same order as in the [Module](types.md#module) object.
* `saltNonces` - Optional salt nonces to use. If not provided, will be randomly generated.

_**Response**_:

```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
  newInstances: Array<`0x${string}`>;
}
```

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.
* `newInstances` - The address of the new module instances.

### predictHatsModuleAddress

Predict a module's address before/after it was created, using its creation arguments.

```typescript
const predictedAddress = await hatsModulesClient.predictHatsModuleAddress({
    moduleId,
    hatId,
    immutableArgs,
    saltNonce,
});
```

_**Arguments**_:

```typescript
{
   moduleId: string;
   hatId: bigint;
   immutableArgs: unknown[];
   saltNonce: bigint;
}
```

* `moduleId` - Module's ID.
* `hatId` - The target hat ID, as provided to the [instance creation function](create-new-instance-s.md#createnewinstance).
* `immutableArgs` - The module's immutable args, as provided to the [instance creation function](create-new-instance-s.md#createnewinstance).
* `saltNonce` - Salt nonce to use.

_**Response**_:

```typescript
`0x${string}`
```

The predicted module address.

# Composing Modules

The following functions support the usage Eligibility/Toggle modules that compose other existing modules with "and"/"or" logical operations. Check out the documentation [here](../../building-hats-modules/about-module-chains.md) to learn more.

### Create New Eligibility/Toggle Chains

### createEligibilitiesChain

Create a new eligibilities chain module.&#x20;

```typescript
const createInstanceResult = await hatsModulesClient.createEligibilitiesChain({
    account,
    hatId,
    numClauses,
    clausesLengths,
    modules,
    saltNonce,
});
```

_**Arguments**_:

```typescript
{
    account: Account | Address;
    hatId: bigint;
    numClauses: number;
    clausesLengths: number[];
    modules: `0x${string}`[];
    saltNonce?: bigint;
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `hatId` - The hat ID for which the module is created.
* `numClauses` - Number of conjunction clauses.
* `clausesLengths` - Length of each clause.
* `modules`- Array of module instances to chain, at the order corresponding to the provided clauses.
* `saltNonce` - Optional salt nonce to use. If not provided, will be randomly generated.

_**Response**_:

```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
  newInstance: `0x${string}`;
}
```

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.
* `newInstance` - In case of success, the address of the new chain module instance.

### createTogglesChain

Create a new toggles chain module.

```typescript
const createInstanceResult = await hatsModulesClient.createTogglesChain({
    account,
    hatId,
    numClauses,
    clausesLengths,
    modules,
    saltNonce,
});
```

_**Arguments**_:

```typescript
{
    account: Account | Address;
    hatId: bigint;
    numClauses: number;
    clausesLengths: number[];
    modules: `0x${string}`[];
    saltNonce?: bigint;
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `hatId` - The hat ID for which the module is created.
* `numClauses` - Number of conjunction clauses.
* `clausesLengths` - Length of each clause.
* `modules`- Array of module instances to chain, at the order corresponding to the provided clauses.
* `saltNonce` - Optional salt nonce to use. If not provided, will be randomly generated.

_**Response**_:

```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
  newInstance: `0x${string}`;
}
```

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.
* `newInstance` - In case of success, the address of the new chain module instance.

### Read From Eligibility/Toggle Chains

The following functions support reading from chain module instances.&#x20;

### getRulesets

Get the rulesets of a module instance.

A ruleset is an array of modules which are chained together with an "AND" logical operator. If the module is a chain with multiple rulesets, then these rulesets are chained together with an "OR" logical operator.

If the provided address is a single module instance (not a chain), then the result will be a single ruleset, which will consist of the single module instance.

```typescript
const rulesets = await hatsModulesClient.getRulesets(address);
```

_**Arguments**_:

```typescript
`0x${string}`
```

Instance address.

_**Response**_:

```typescript
Ruleset[] | undefined
```

The module's [rulesets](types.md#ruleset), or `undefined` if the provided address is not a module.

### getRulesetsBatched

Get the rulesets of multiple module instances.

A ruleset is an array of modules which are chained together with an "AND" logical operator. If the module is a chain with multiple rulesets, then these rulesets are chained together with an "OR" logical operator.

If the provided address is a single module instance (not a chain), then the result will be a single ruleset, which will consist of the single module instance.

```typescript
const rulesets = await hatsModulesClient.getRulesetsBatched(addresses);
```

_**Arguments**_:

```typescript
`0x${string}`[]
```

Array of instance addresses.

_**Response**_:

```typescript
(Ruleset[] | undefined)[]
```

For each module instance, returns the module's [rulesets](types.md#ruleset), or `undefined` if the provided address is not a module.

### isChain

Check whether a module instance is a modules chain.

```typescript
const isChain = await hatsModulesClient.isChain(address);
```

_**Arguments**_:

```typescript
`0x${string}`
```

Instance address.

_**Response**_:

```typescript
boolean
```

`true` if the instance is a chain, `false` otherwise.

### isChainBatched

Check whether multiple module instances are modules chains.

```typescript
const isChainBatched = await hatsModulesClient.isChainBatched(addresses);
```

_**Arguments**_:

```typescript
`0x${string}`[]
```

Instance addresses.

_**Response**_:

```typescript
boolean[]
```

For each instance, `true` if the instance is a chain, `false` otherwise.

# Interact With Instances

The following functions provide utilities to support the interaction with module instances: checking whether a certain instance was created, reading instance's [display parameters](types.md#module) (as specified in the 'parameter' property in the Module's object) and calling its write functions.

To get the module's object from an instance address, use [this function](../../modules-sdk/get-available-modules.md#getmodulebyinstance).

## isModuleDeployed

Check if a module is already deployed, using its creation arguments.

```typescript
const isDeployed = await hatsModulesClient.isModuleDeployed({
    moduleId,
    hatId,
    immutableArgs,
    saltNonce,
});
```

_**Arguments**_:

```typescript
{
   moduleId: string;
   hatId: bigint;
   immutableArgs: unknown[];
   saltNonce: bigint;
}
```

* `moduleId` - Module's ID.
* `hatId` - The target hat ID, as provided to the [instance creation function](create-new-instance-s.md#createnewinstance).
* `immutableArgs` - The module's immutable args, as provided to the [instance creation function](create-new-instance-s.md#createnewinstance).
* `saltNonce` - Salt nonce to use.

_**Response**_:

```typescript
boolean
```

`true` if the module was deployed, `false` otherwise.

## getInstanceParameters

Get a module's instance live parameters.&#x20;

The parameters to fetch are listed in the [Module's registry object](types.md#module) (in the 'parameters' property), and their purpose is to display relevant information for each module instance.

```typescript
const module = await hatsModulesClient.getInstanceParameters(instance);
```

_**Arguments**_:

```typescript
instance: `0x${string}`
```

`instance` - Instance's address.

_**Response**_:

```typescript
{
  label: string;
  value: unknown;
  solidityType: string;
  displayType: string;
}[]
```

An array of objects, each containing a parameter's information:

* `label` - The parameter's name/description.
* `value` - The parameter's value, as was returned from the instance contract.
* `solidityType` - The parameter's Solidity type.
* `displayType`- The parameter's display type. Its purpose is for UIs to be able to render an appropriate component for the parameter. For example, rendering a date for timestamps.

### callInstanceWriteFunction

Call a module's write function.

The 'customRoles' and 'writeFunctions' properties of a [Module's object](types.md#module) enable to programmatically get all the write functions of a module, together with any necessary information to call them: expected input arguments and the roles (Hats) that have the permission to call each function.

```typescript
const res = await hatsModulesClient.callInstanceWriteFunction({
    account,
    moduleId,
    instance,
    func,
    args,
});
```

_**Arguments**_:

```typescript
{
    account: Account | Address;
    moduleId: string;
    instance: Address;
    func: WriteFunction;
    args: unknown[];
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `moduleId` - Module's ID (implementation address).
* `instance` - Instance's address.
* `func` - The function to call, provided as an object of [WriteFunction](types.md#writefunction) type.
* `args` - The input arguments to pass the function.

_**Response**_:

```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
}
```

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.

# Utilities

## getSchema

The SDK uses Zod schemas in order to verify inputs for [createNewInstance](broken-reference), according to their target Solidity types. The `getSchema` function is exported as a utility function, to get the Zod schema for a corresponding Solidity type.

```typescript
import { getSchema } from "@hatsprotocol/modules-sdk";

const schema = getSchema(solidityType);
```

_**Arguments**_:

```typescript
solidityType: string
```

`solidityType` - The name of the Solidity type, e.g. "uint256".

_**Response**_:

```typescript
ZodType
```

The Zod schema for the provided type.&#x20;

## verify

Verify a value according to its target Solidity type.

```typescript
import { verify } from "@hatsprotocol/modules-sdk";

const isValid = verify(val, type);
```

_**Arguments**_:

```typescript
(val: unknown, type: string)
```

* `val` - The value to verify.
* `type` - The target Solidity type for the provided value.

_**Response**_:

```typescript
boolean
```

`true` if the provided value is compatible with the Solidity type, `false` otherwise.

## solidityToTypescriptType

Utility function that maps between a Solidity type to its compatible Typescript type.

```typescript
import { solidityToTypescriptType } from "@hatsprotocol/modules-sdk";

const tsType = solidityToTypescriptType(solidityType);
```

_**Arguments**_:

```typescript
solidityType: string
```

`solidityType` - The name of the Solidity type, e.g. "uint256".

_**Response**_:

```typescript
"number"    | 
"bigint"    |
"string"    |
"boolean"   |
"number[]"  | 
"bigint[]"  | 
"string[]"  | 
"boolean[]" | 
"unknown"
```

The name of the Typescript type which is compatible to the provided Solidity one.

## checkAndEncodeArgs

Check and encode the immutable and mutable arguments for module creation.

This is a utility function for interacting with the [HatsModuleFactory](../building-hats-modules/how-module-instances-are-deployed.md) directly, rather than using the [createNewInstance](create-new-instance-s.md#createnewinstance) function from the SDK. This may be useful in cases where the module creation is proxied by another contract and expects similar input parameters as the [createHatsModule](https://github.com/Hats-Protocol/hats-module/blob/38f80eed6ce444f924f5982858daf75e724be6f9/src/HatsModuleFactory.sol#L69C12-L69C28) function from the factory.

```typescript
import { checkAndEncodeArgs } from "@hatsprotocol/modules-sdk";

const { encodedImmutableArgs, encodedMutableArgs } = checkAndEncodeArgs({
   module,
   immutableArgs,
   mutableArgs,
});
```

_**Arguments**_:

```typescript
{
  module: Module;
  immutableArgs: unknown[];
  mutableArgs: unknown[];
}
```

`module` - The module object of the module that will be created.

`immutableArgs` - The module's immutable arguments.

`mutableArgs` - The modules's mutable arguments.

_**Response**_:

```typescript
{
  encodedImmutableArgs: "" | `0x${string}`;
  encodedMutableArgs: "" | `0x${string}`;
}
```

The encoded immutable and mutable arguments, as expected by the [createHatsModule](https://github.com/Hats-Protocol/hats-module/blob/38f80eed6ce444f924f5982858daf75e724be6f9/src/HatsModuleFactory.sol#L69C12-L69C28) function from the factory.&#x20;

## checkImmutableArgs

Check the immutable arguments for module creation.

Checks that the provided immutable arguments are valid according to the module's schema from the registry. If not, the function will throw a detailed error.

```typescript
import { checkImmutableArgs } from "@hatsprotocol/modules-sdk";

checkImmutableArgs({ module, immutableArgs });
```

_**Arguments**_:

```typescript
{
  module: Module;
  immutableArgs: unknown[];
}
```

`module` - The module object of the module that will be created.

`immutableArgs` - The module's immutable arguments.

## checkMutableArgs

Check the mutable arguments for module creation.

Checks that the provided mutable arguments are valid according to the module's schema from the registry. If not, the function will throw a detailed error.

```typescript
import { checkMutableArgs } from "@hatsprotocol/modules-sdk";

checkMutableArgs({ module, mutableArgs });
```

_**Arguments**_:

```typescript
{
  module: Module;
  mutableArgs: unknown[];
}
```

`module` - The module object of the module that will be created.

`mutableArgs` - The module's mutable arguments.

## getNewInstancesFromReceipt

Get the addresses of newly created module instance/s, using the creation transaction receipt.

```typescript
import { getNewInstancesFromReceipt } from "@hatsprotocol/modules-sdk";

const instances = getNewInstancesFromReceipt(receipt);
```

_**Arguments**_:

```typescript
receipt: TransactionReceipt
```

`receipt` - The transaction receipt as a TransactionReceipt Viem object.

_**Response**_:

```typescript
`0x${string}`[]
```

An array of the newly created instances/s.

# Types

## Module

Represents a module object, compatible with the registry's module objects.

```typescript
{
  name: string; // module's name
  details: string[]; // array of strings representing paragraphs that describe the module to end users.
  links: { // relevant links about the module
    label: string; // link's name
    link: string; // URL
  }[];
  parameters: { // module's dispaly parameters, chosen by its creator as relevant for dispaly to end users
    label: string; // parameter's name
    functionName: string; // name of the view or pure function that gets the parameter value
    displayType: string; // a free-text field that tells front ends how to generate a proper UI component for the parameter
  }[];
  type: { // type of module
    eligibility: boolean;
    toggle: boolean;
    hatter: boolean;
  };
  tags: {
    description: string;
    label: string;
    value: string;
  }[];
  implementationAddress: string; // module's implementation address, equal in every network
  deployments: { // networks the implementation is deployed and supported
    chainId: string; // chain's ID
    block: string; // block number of the deployment transaction
  }[];
  creationArgs: ModuleCreationArgs; // the arguments that are passed to the module factory's creation function
  customRoles: Role[]; // module's custom roles
  writeFunctions: WriteFunction[]; // module's write functions
  abi: Abi; // module's ABI
}
```

## Role

A module's custom role. Each module role is associated with a hat and grants permissions to the hat's wearer(s) to call certain functions on the module contract.

There are two special roles with a reserved ID that are automatically added to each module:

1. `public` role, associated with functions that are permitted to any caller
2. `hatAdmins` role, associated with functions that are permitted to the target hat's admins

```typescript
{
  id: string; // role's ID
  name: string; // role's name
  criteria: string; // The name of the contract function which can be used to retrieve the role's hat
  hatAdminsFallback?: boolean; // 'true' indicates that the role is granted to the target hat's admin(s) if/when the role's criteria function returns zero.
}
```

## WriteFunction

The module's write functions. Each write function is associated with a role and grants permissions to the role's wearer(s) to call the function on the module contract.

```typescript
{
  roles: string[]; // IDs of the roles that have the authority to call the function
  functionName: string; // the name of the function in the contract
  label: string; // the name to be displayed to end users
  description: string; // a description of the function to be displayed to end users
  primary?: boolean; // 'true' indicates that this function is the primary function of the roles it is associated with. Front ends can use this information to display the function more prominently for each role
  args: WriteFunctionArg[]; // the arguments of the function
}
```

## WriteFunctionArg

Module write function argument.

```typescript
{
  name: string; // arg's name 
  description: string; // arg's description
  type: string; // arg's solidity type, e.g. 'uint256'
  displayType: string; // a free-text field that tells front ends how to generate a proper UI component for the parameter
  optional?: boolean; // setting to 'true' indicates that this input is optional
}
```

## ModuleCreationArgs

The arguments that are passed to the module [factory's creation function](create-new-instance-s.md#createnewinstance). The arguments are divided into two arrays: `immutable` and `mutable`. The `immutable` array contains arguments that are set once when the module instance is created and cannot be changed. The `mutable` array contains arguments that can be changed after the module instance is created.

* `useHatId` - By default, new instances should be created with the `hatId` value set to the target hat's ID.  A `false` value here indicates that the module's `hatId` value should be set to zero.
* In both the `immutable` and `mutable` array properties, the order of the arguments must match the order expected by the contract.

```typescript
{
  useHatId: boolean; 
  immutable: ModuleCreationArg[];
  mutable: ModuleCreationArg[];
}
```

## ModuleCreationArg

Immutable/mutable argument, provided in the module's [creation arguments](types.md#modulecreationargs).

<pre class="language-typescript"><code class="lang-typescript">{
  name: string; // arg's name
  description: string; // arg's description
  type: string; // arg's solidity type, e.g. 'uint256'
  example: unknown; // example value 
  displayType: string; // a free-text field that tells front ends how to generate a proper UI component for the parameter
<strong>  optional?: boolean;
</strong>}
</code></pre>

## Registry

A [Hats Modules Registry](../building-hats-modules/modules-registry.md) object.

```typescript
{
  modules: Module[];
}
```

## ModuleParamete

Module parameter object, as returned by the [getInstanceParameters](interact-with-instances.md#getinstanceparameters) function.

```typescript
{
  label: string;
  value: unknown;
  solidityType: string;
  displayType: string;
}
```

## ArgumentTsType

A Typescript type, as returned by the [solidityToTypescriptType function](utilities.md#soliditytotypescripttype).

```typescript
| "number"
| "bigint"
| "string"
| "boolean"
| "number[]"
| "bigint[]"
| "string[]"
| "boolean[]"
| "unknown";
```

## Ruleset

A modules ruleset is an array of module instances which are chained together with an 'AND' logical operator.&#x20;

```typescript
{
  module: Module; // the module's object from the registry
  address: `0x${string}`; // the module's instance address
}[]
```

# âš’ Building Hats Modules

This section provides an overview of how Hats modules are built and deployed into production. In the docs below, you'll learn how to create new modules and about the tools we've developed to make that easier.

## Developer Community

For technical support, questions, and to explore/share ideas, join the [Hats Protocol Dev Chat](https://t.me/+HrcKPUxaWvg3Zjhh) on Telegram.

## All About Hats Modules

{% content-ref url="inside-a-hats-module/" %}
[inside-a-hats-module](inside-a-hats-module/)
{% endcontent-ref %}

{% content-ref url="creating-new-modules.md" %}
[creating-new-modules.md](creating-new-modules.md)
{% endcontent-ref %}

{% content-ref url="how-module-instances-are-deployed.md" %}
[how-module-instances-are-deployed.md](how-module-instances-are-deployed.md)
{% endcontent-ref %}

{% content-ref url="modules-registry.md" %}
[modules-registry.md](modules-registry.md)
{% endcontent-ref %}

{% content-ref url="../../building-hats-modules/about-module-chains.md" %}
[about-module-chains.md](../../building-hats-modules/about-module-chains.md)
{% endcontent-ref %}

# Inside a Hats Module

Typically, Hats Modules inherit from the [HatsModule.sol](https://github.com/Hats-Protocol/hats-module/blob/main/src/HatsModule.sol) contract. This is an abstract contract that provides a generic structure that modules can extend to support any specific use case.

It serves several key functions:

1. Provide the basic boiler plate required for a new Hats module contract.
2. Enable compatibility with [HatsModuleFactory.sol](../how-module-instances-are-deployed.md), the easiest and cheapest way for users to deploy new instances of a given module.
3. Enable compatibility with the [module registry](https://github.com/Hats-Protocol/modules-registry), which facilitates user discovery and integration into Hats front ends.

{% hint style="info" %}
Inheriting from HatsModule.sol is necessary to be deployable via HatsModuleFactory, to be listed in the Module registry, and to appear natively in the applications using the registry.&#x20;

However, it is _not_ required for compatibility with Hats Protocol more generally. See the docs for [Eligibility](../../../hats-protocol-for-developers/eligibility-modules.md) and [Toggle](../../../hats-protocol-for-developers/toggle-modules.md) modules for those requirements.

The remainder of this documentation assumes inheritance of HatsModule.
{% endhint %}

## HatsModule.sol

HatsModule.sol's primary function is to enable a module to be configured and deployed via [HatsModuleFactory](../how-module-instances-are-deployed.md). Often, each new hat to which a module is attached involves a new instance of that module, so its important for deployment to be gas-efficient. Additionally, each module is likely to be called many times over its life, so its also important for runtime execution to be gas-efficient.&#x20;

For these reasons, HatsModule.sol is structured as a minimal proxy (clone) contract â€” similar to the [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167) standard â€” that also supports immutable arguments. It implements the gas-efficient [LibClone.sol](https://github.com/Vectorized/solady/blob/6c54795ef69838e233020e9ab29f3f6288efdf06/src/utils/LibClone.sol) library.

See the following pages for more detail about how HatsModule.sol operates:

{% content-ref url="immutable-arguments.md" %}
[immutable-arguments.md](immutable-arguments.md)
{% endcontent-ref %}

{% content-ref url="module-setup.md" %}
[module-setup.md](module-setup.md)
{% endcontent-ref %}

{% content-ref url="versioning.md" %}
[versioning.md](versioning.md)
{% endcontent-ref %}

## Extensions

There are a couple stock extensions to HatsModule.sol that are useful starting points for common types of modules:

* HatsEligibilityModule.sol: implements [`IHatsEligibility.sol`](../../../hats-protocol-for-developers/eligibility-modules.md)
* HatsToggleModule.sol: implements [`IHatsToggle.sol`](../../../hats-protocol-for-developers/toggle-modules.md)

# Immutable Arguments

Immutable arguments are variables which are set at each module instance creation (via the HatsModuleFactory) and are then constant through out the instance's lifetime.&#x20;

Accessing these variables is significantly cheaper than accessing regular storage variables, and so using this kind of variables is recommended for any variables which can be defined once, during instance creation, and then stay constant.

## Standard HatsModule Immutable Args

HatsModule includes several immutable arguments as standard, which are then included in any inheriting module.&#x20;

* `IMPLEMENTATION`: The address of the implementation contract of which the instance is a clone.
* `HATS`: The Hats Protocol address (Hats.sol).
* `hatId`: The hat ID for which the instance has been deployed. This can be utilized in various ways depending on the module's use case.

## Immutable Arg "Storage"

LibClone.sol handles "storage" of these values in the instance's bytecode, with the following layout:

<table><thead><tr><th width="105">Offset</th><th>Constant</th><th width="111">Type</th><th width="115">Length</th><th>Source</th></tr></thead><tbody><tr><td>0</td><td>IMPLEMENTATION</td><td>address</td><td>20</td><td>HatsModule</td></tr><tr><td>20</td><td>HATS</td><td>address</td><td>20</td><td>HatsModule</td></tr><tr><td>40</td><td>hatId</td><td>address</td><td>32</td><td>HatsModule</td></tr><tr><td>[72+]</td><td>[other args]</td><td>[type]</td><td>[len]</td><td>[your module]</td></tr></tbody></table>

Each is accessible by a pure function based on utility functions from LibClone.sol.

```solidity
function IMPLEMENTATION() public pure returns (address) {
    return _getArgAddress(0);
}

function HATS() public pure returns (IHats) {
    return IHats(_getArgAddress(20));
}

function hatId() public pure returns (uint256) {
    return _getArgUint256(40);
}
```

## Custom Immutable Arguments

Modules can include as many additional immutable arguments as they need, and each can be made accessible by similar pure functions.

Note that the immutable arguments of an instance are passed to the [createHatsModule](../how-module-instances-are-deployed.md#create-new-instance) function in the factory, rather than to the instance's contract itself. See the next section for more details on how that works.

# Module Setup

Each module instance is initialized at creation time by the public [setUp](https://github.com/Hats-Protocol/hats-module/blob/5a69da357e70cc2e3727d6ec02097711439ec32b/src/HatsModule.sol#L65) function, which is triggered by the [`createHatsModule`](../how-module-instances-are-deployed.md#create-new-instance)  function in [HatsModuleFactory](../how-module-instances-are-deployed.md). This is where custom initial (mutable) variables and other configurations are set.

That custom logic can be implemented in the virtual [\_setUp](https://github.com/Hats-Protocol/hats-module/blob/5a69da357e70cc2e3727d6ec02097711439ec32b/src/HatsModule.sol#L70) function, which the module implementation should override.

```solidity
function _setUp(bytes calldata _initData) internal virtual { }
```

_Parameters:_

* `_initData` - abi-encoded initialization data.

{% hint style="info" %}
The `setUp` function is modified by OpenZeppelin's [initializable](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/utils/Initializable.sol), which prevents any future calls that could re-initialize the instance. `setUp` will be called even if `_setUp` is empty, ensuring that all instances are properly initialized.
{% endhint %}

# Versioning

HatsModule includes a single storage variable for versioning purposes.

```solidity
string public version_;
```

This variable is set in the constructor, which means that it has a value only in the implementation contract and not in any instances (since instance clones are not created with the constructor).

To get the version for a module instance use the [version](https://github.com/Hats-Protocol/hats-module/blob/5a69da357e70cc2e3727d6ec02097711439ec32b/src/HatsModule.sol#L56) function instead.

```solidity
function version() public view returns (string memory) {
    return HatsModule(IMPLEMENTATION()).version_();
}
```

# Creating New Modules

## Getting Started

The [hats-module-template](https://github.com/Hats-Protocol/hats-module-template) repository makes it easy to get started building a new module. It has everything you need, including:

* An initialized Foundry project with a Hats-relevant config.
* Initial dependencies added: `forge-std` and `hats-module`.
* A stubbed out starter module contract.
* Test & deployment files boilerplate.
* Github CI workflows for Forge tests and gas cost diffs.

For eligibility modules, import and inherit from the [HatsEligibilityModule](https://github.com/Hats-Protocol/hats-module/blob/main/src/HatsEligibilityModule.sol) contract, which inherits from HatsModule and additionally implements the [IHatsEligibility](../../v1-protocol-spec/interfaces/ihatseligibility.sol.md) interface:

```solidity
import { HatsEligibilityModule } from "hats-module/HatsModule.sol";
```

Similarly, for toggle modules, import and inherit from the [HatsToggleModule](https://github.com/Hats-Protocol/hats-module/blob/main/src/HatsToggleModule.sol) contract, which inherits from HatsModule and additionally implements the [IHatsToggle](../../v1-protocol-spec/interfaces/ihatstoggle.sol.md) interface:

```solidity
import { HatsToggleModule } from "hats-module/HatsModule.sol";
```

## Best Practices

For compatibility with [module chains](../../building-hats-modules/about-module-chains.md), it is strongly recommended to adhere to the following practices:

### Pull, don't push

Avoid pushing hat or hat wearer status directly to the protocol, i.e. via `IHats.setHatStatus` or `IHats.setHatWearerStatus`. These functions are only authorized to contracts set directly on the given hat as the toggle or eligibility module, respectively. Those calls would therefore revert when called from a module in a chain.

The simplest alternative is to not force the protocol to recognize any status updates, just let it pull them in dynamically the next time they are checked.

If you must have the protocol immediately recognize a new status, have the protocol pull the updates, ie via `IHats.checkHatStatus` or `IHats.checkHatWearerStatus`. These are fully public functions that will trigger the protocol to pull the current status from the modules set on the hat; if that's a chain, it will read from all the modules in the chain.

### Don't force claiming

Some eligibility modules (such as [agreement-eligibility.md](../../../hats-integrations/eligibility-and-accountability-criteria/agreement-eligibility.md "mention") and [staking-eligibility.md](../../../hats-integrations/eligibility-and-accountability-criteria/staking-eligibility.md "mention")) include an option for would-be-wearers to [claim the hat](../../v1-sdk/core/claiming-hats.md) at the same time as they take an action to become eligible (e.g., signing the agreement and staking, respectively).

When building such a module, avoid _requiring_ that would-be-wearers claim the hat at the same time as taking the action to become eligible. Instead, give them an option to take the qualifying action independently, as well as bundled with claiming. _This will allow your module to work properly even when chained with another module that uses the qualifying action + claim approach_.

This is necessary because of the way the protocol handles minting when an eligibility module is attached to the hat. With a module attached, the protocol will only allow the hat to be minted if the recipient wearer is "explicitly eligible," i.e. eligible according to the module. In the case of a module chain, this will include eligibility information from all the modules in the chain, and so the would-be wearer may not be eligible for the hat as a whole even after they execute the qualifying action for one of its chained modules.

## Learn From Examples

To learn more and get inspiration, check out the awesome module that are already here:

* [Eligibility Modules](../../../hats-integrations/eligibility-and-accountability-criteria/#existing-modules)
* [Toggle Modules](../../../hats-integrations/activation-and-deactivation-criteria/#existing-modules)
* [Hatter Modules](../../../hats-integrations/hatter-modules/#existing-modules)

# How Module Instances Are Deployed

All contracts that inherit from [HatsModule](https://github.com/Hats-Protocol/hats-module/blob/main/src/HatsModule.sol) can be deployed as minimal proxy clones via [HatsModuleFactory](https://github.com/Hats-Protocol/hats-module/blob/main/src/HatsModuleFactory.sol), which offers several operations:

* create a single module instance
* batch create multiple module instances
* predict the address of a module instance
* check if a module instance has already been deployed

Each of these functions can be called directly on the HatsModuleFactory contract, or they can be accessed via the [Modules SDK](../modules-sdk/) to easily deploy new module instances and more.

## Create New Instance

The [createHatsModule](https://github.com/Hats-Protocol/hats-module/blob/5a69da357e70cc2e3727d6ec02097711439ec32b/src/HatsModuleFactory.sol#L69) function deploys a new proxy instance, for the provided implementation, to a deterministic address. The instance's immutable arguments are set its creation, and then `instance.setUp` is called with the provided initialization data.

```solidity
function createHatsModule(
    address _implementation,
    uint256 _hatId,
    bytes calldata _otherImmutableArgs,
    bytes calldata _initData
) public returns (address _instance)
```

_Parameters:_

* `_implementation` - The address of the implementation contract for which to deploy a clone.
* `_hatId` - The hat for which to deploy the module.
* `_otherImmutableArgs`: Immutable arguments to pass to the clone, packed encoded (via `abi.encodePacked`). These are additional to the ones [already included in HatsModule](inside-a-hats-module/#immutable-arguments).
* `_initData` - Encoded data (via abi.encode) to pass to the `setUp` function of the new instance.

_Returns_:

* `_instance` - The new instance's address.

_Events_:

Once the new module deployment and setup have completed, the function will emit the following event, which contains the new instance address:

```solidity
event HatsModuleFactory_ModuleDeployed(
    address implementation, address instance, uint256 hatId, bytes otherImmutableArgs, bytes initData
);
```

## Batch Create Multiple Instances

The [batchCreateHatsModule](https://github.com/Hats-Protocol/hats-module/blob/5a69da357e70cc2e3727d6ec02097711439ec32b/src/HatsModuleFactory.sol#L106) function creates multiple instances, using the [createHatsModule](how-module-instances-are-deployed.md#create-new-instance) function.&#x20;

The necessary creation parameters are passed as arrays, which must have the same length, equal to the number of modules to be created. For each module, the `createHatsModule` function will be called with the arrays entries, on the same corresponding index.

```solidity
function batchCreateHatsModule(
    address[] calldata _implementations,
    uint256[] calldata _hatIds,
    bytes[] calldata _otherImmutableArgsArray,
    bytes[] calldata _initDataArray
) public returns (bool success)
```

_Parameters:_

* `_implementations` - The addresses of the implementation contracts for which to deploy a clone.
* `_hatIds` - The hats for which to deploy the modules.
* `_otherImmutableArgsArray`: Immutable argumentss to pass to the clones, packed encoded (via `abi.encodePacked`). These are additional to the ones [already included in HatsModule](inside-a-hats-module/#immutable-arguments).
* `_initDataArray` - Encoded data (via abi.encode) to pass to the `setUp` function of each new module instance.

_Returns_:

* `success` - `True` if all modules were successfully created and initialized, `false` otherwise.

_Events_:

For every successfully created module, the function will emit the following event, which contains the new instance address:

```solidity
event HatsModuleFactory_ModuleDeployed(
    address implementation, address instance, uint256 hatId, bytes otherImmutableArgs, bytes initData
);
```

## Predict Module's Address

The [getHatsModuleAddress](https://github.com/Hats-Protocol/hats-module/blob/5a69da357e70cc2e3727d6ec02097711439ec32b/src/HatsModuleFactory.sol#L136) function predicts the address of a module instance before it was created.

```solidity
function getHatsModuleAddress(address _implementation, uint256 _hatId, bytes calldata _otherImmutableArgs)
    public
    view
returns (address)
```

_Parameters:_

* `_implementation` - The address of the implementation contract.
* `_hatId` - The hat for which to deploy a module.
* `_otherImmutableArgs`: Immutable arguments to pass to the clone, packed encoded (via `abi.encodePacked`). These are additional to the ones [already included in HatsModule](inside-a-hats-module/#immutable-arguments).

_Returns_:

* The predicted instance address.&#x20;

## Check If Deployed

The [deployed](https://github.com/Hats-Protocol/hats-module/blob/5a69da357e70cc2e3727d6ec02097711439ec32b/src/HatsModuleFactory.sol#L154) function checks if a certain module instance has been deployed.

```solidity
function deployed(address _implementation, uint256 _hatId, bytes calldata _otherImmutableArgs)
    public
    view
returns (bool)
```

_Parameters:_

* `_implementation` - The address of the implementation contract.
* `_hatId` - The hat for which to deploy a module.
* `_otherImmutableArgs`: Immutable arguments to pass to the clone, packed encoded (via `abi.encodePacked`). These are additional to the ones [already included in HatsModule](inside-a-hats-module/#immutable-arguments).

_Returns_:

* `True` if the instance has been deployed, `false` otherwise.&#x20;

## HatsModuleFactory Deployments

HatsModuleFactory [v0.6.0](https://github.com/Hats-Protocol/hats-module/releases/tag/v0.6.0) is deployed to the same address on all networks: 0xfE661c01891172046feE16D3a57c3Cf456729efA

It is known to have been deployed to the following networks:

* [Ethereum Mainnet](https://etherscan.io/address/0xfE661c01891172046feE16D3a57c3Cf456729efA)
* [Optimism](https://optimistic.etherscan.io/address/0xfE661c01891172046feE16D3a57c3Cf456729efA)
* [Gnosis Chain](https://gnosisscan.io/address/0xfE661c01891172046feE16D3a57c3Cf456729efA)
* [Polygon](https://polygonscan.com/address/0xfe661c01891172046fee16d3a57c3cf456729efa)
* [Arbitrum](https://arbiscan.io/address/0xfe661c01891172046fee16d3a57c3cf456729efa)
* [PGN](https://explorer.publicgoods.network/address/0xfE661c01891172046feE16D3a57c3Cf456729efA)
* [Celo](https://explorer.celo.org/mainnet/address/0xfE661c01891172046feE16D3a57c3Cf456729efA)
* [Base](https://basescan.org/address/0xfe661c01891172046fee16d3a57c3cf456729efa)
* [Sepolia testnet](https://sepolia.etherscan.io/address/0xfe661c01891172046fee16d3a57c3cf456729efa)
* [Goerli testnet](https://goerli.etherscan.io/address/0xfE661c01891172046feE16D3a57c3Cf456729efA)

# Modules Registry

Creating new modules is important, but they really only come to life when users of Hats Protocol can attach them to hats. We've built several tools to help developers put modules in the hands of users.

* [Modules Registry](https://github.com/Hats-Protocol/modules-registry)
* [Modules SDK](../modules-sdk/)

## Modules Registry

The Hats Modules Registry is a curated modules database. Tools, apps, and platforms in the Hats ecosystem â€” including the [Modules SDK](../modules-sdk/) â€” use it as the source of truth for safe, high quality modules they can serve to users and other developers.&#x20;

Today, the primary consumer of the registry is the Modules SDK, which is used by the [Hats App](https://app.hatsprotocol.xyz/) to enable users to easily discover, configure, and attach modules to hats.

## Submit a module to the registry

To submit a module to the registry, open a pull requests to the [registry repo](https://github.com/Hats-Protocol/modules-registry). You will need the following information for your submission:

* Module name
* Module description
* The module's Github repo and repo owner/org
* The module type: eligibility, toggle, and/or hatter
* Implementation contract address
* Deployments to the implementation address, including chain ID and block number
* The list of immutable args, with name, description, type, and example for each
* The list of mutable args (initData), with name, description, type, and example for each
* The module's ABI

For more specifics on the submission requirements, see the [registry repo README](https://github.com/Hats-Protocol/modules-registry/blob/main/README.md).

## Governance

The registry is currently governed and curated by the Hats Protocol core team. Over time, however, curation will decentralize to the wider Hats community.

{% hint style="info" %}
Modules do not need to be on the registry to be compatible at the protocol level. Hats Protocol itself is fully permissionless. The registry is a separate mechanism.
{% endhint %}

# About Module Chains

What if you want an eligibility criteria to be a combination of conditions implemented in separate modules? For example, to be eligible, a person has to own a certain NFT (e.g. representing a DAO membership) and additionally win an election? That's exactly what the eligibilities/toggles chain modules are for.

[HatsEligibilitiesChain](https://github.com/Hats-Protocol/hats-module/blob/main/src/HatsEligibilitiesChain.sol) is an eligibility module that composes any amount of eligibility modules with "and"/"or" logical operations. Similarly, [HatsTogglesChain](https://github.com/Hats-Protocol/hats-module/blob/main/src/HatsTogglesChain.sol) is a toggle module that composes any amount of toggle modules.

Both of these modules have a similar structure. Modules are chained in a format of a disjunction of conjunction clauses. For example, "(module1 && module2) || module3" has 2 conjunction clauses:&#x20;

1. "(module1 && module2)
2. "module3"&#x20;

These clauses are chained together with an "or" operation.&#x20;

**Deriving Wearer Eligibility:**

For the eligibilities chain module, a wearer's eligibility is derived by checking eligibility in each module and combining the results according to the chosen logical operations. However, if a wearer is in a bad standing according to any one of the modules, then the module will return a result of "not eligible" and "is in bad standing".

**Deriving Hat Status:**

For the toggles chain module, a hat's status is derived by checking it's status in each module and combining the results according to the chosen logical operations.&#x20;

### Create New Eligibilities/Toggles Chain Module

The module does not use any mutable storage variables and does not use initialization data. It only uses the following immutable variables, which are set at the module instance's creation time:

1. Number of conjunction clauses.
2. Conjunction clauses lengths.
3. The list of eligibility/toggle modules.

Using the example above, here's an example immutable arguments that will be used for the module's deployment:

```solidity
bytes memory otherImmutableArgs = abi.encodePacked(2, [2,1], module1Address, module2Address, module3Address);
```

The module includes the following getters for these immutable variables:

```solidity
function NUM_CONJUCTION_CLAUSES() public pure returns (uint256)

function CONJUCTION_CLAUSE_LENGTHS() public pure returns (uint256[] memory)

function MODULES() public pure returns (address[] memory)

```

# ðŸ” Hats Signer Gate v2

Hats Signer Gate (HSG) v2 is a contract that grants multisig signing rights to addresses wearing a given hats, enabling on-chain organizations to revocably delegate to individuals constrained authority and responsibility to operate an account (i.e. a Safe) owned by the organization.

## **Zodiac Module**

[HatsSignerGate.sol](https://github.com/hats-protocol/hats-zodiac) is a [Zodiac](https://github.com/gnosisguild/zodiac) **module** that...

1. Grants multisig signing rights to addresses based on whether they are wearing the appropriate Hat(s).
2. Removes signers who are no long valid (i.e. no longer wearing the signer Hat)
3. Manages the multisig threshold within the owner-specified range as new signers are added or removed.

## **Zodiac Guard**

Since Hat-wearing is dynamic â€” Hats can be programmatically revoked from wearers â€” this contract also services as a [Zodiac](https://github.com/gnosisguild/zodiac) **guard** to ensure that:

A) **Only valid signers can execute transactions**, i.e. only signatures made by accounts currently wearing a valid signer Hat count towards the threshold.

B) **Signers cannot execute transactions that remove the constraint in (A)**. Specifically, this contract guards against signers...

1. Executing _calls_ to the Safe itself. This prevents the signers from changing any of the Safe's storage values, including those referenced below.
2. Executing _delegatecalls_ to any [target contract](hats-signer-gate-v2.md#delegatecall-targets) not approved by the HSG owner
3. Executing any delegatecall (even to an approved target contract) that does the any of following
   1. Removes HSG as a guard on the Safe
   2. Removes HSG as a module on the Safe â€” or changing/adding any other modules
   3. Changes the Safe threshold
   4. Changes the Safe owners (aka signers)
   5. Changes the Safe fallback handler

{% hint style="warning" %}
Protections against (3c) and (3d) above only hold if the Safe does not have any authority over the signer Hat(s). If it does â€” e.g. it wears an admin Hat of the signer Hat(s) or is an eligibility or toggle module on the signer Hat(s) â€” then in some cases the signers may be able to indirectly change the Safe threshold or owners.

Proceed with caution if granting such authority to a Safe attached to HatsSignerGate.
{% endhint %}

## Signer Management

Hats Signer Gate provides several ways to manage Safe signers based on their hat-wearing status:

### **Claiming Signer Rights**

* Individual hat wearers can claim their own signing rights via `claimSigner()`
* Must be wearing a valid signer hat at time of claim
* Each signer's hat ID is registered and tracked for future validation

### **Claiming for Others**

When enabled by the owner (`claimableFor = true`):

* Anyone can claim signing rights on behalf of valid hat wearers via `claimSignerFor()` or `claimSignersFor()`
* Useful for batch onboarding of signers
* Prevents re-registration if signer is still wearing their currently registered hat

### **Signer Removal**

* Signers who no longer wear their registered hat can be removed via `removeSigner()`
* Threshold automatically adjusts according to the threshold configuration
* If the removed signer was the last valid signer, the contract itself becomes the sole owner

## Threshold Configuration

The threshold (number of required signatures) is managed dynamically based on the `ThresholdConfig`:

### **Threshold Types**

1. **ABSOLUTE**
   * Sets a fixed target number of required signatures
   * Example: Always require exactly 3 signatures
   * Bounded by min threshold and number of valid signers
2. **PROPORTIONAL**
   * Sets a percentage of total signers required (in basis points)
   * Example: Require 51% of signers (5100 basis points)
   * Actual number of required signatures rounds up
   * Still bounded by min threshold

### **Configuration Parameters**

* `min`: Minimum number of required signatures (must be > 0)
* `target`: Either fixed number (ABSOLUTE) or percentage in basis points (PROPORTIONAL)
* `thresholdType`: ABSOLUTE (0) or PROPORTIONAL (1)

The Safe's threshold is automatically adjusted when:

* New signers are added
* Existing signers are removed
* Threshold configuration is changed

## Delegatecall Targets

HSG restricts delegatecalls to protect the Safe from unauthorized modifications. Only approved targets can receive delegatecalls.

**Default Enabled Targets**

The following MultiSend libraries are enabled by default:

<table><thead><tr><th>Address</th><th width="118">Version</th><th width="100">Type</th></tr></thead><tbody><tr><td><code>0x40A2aCCbd92BCA938b02010E17A5b8929b49130D</code></td><td>v1.3.0</td><td>canonical</td></tr><tr><td><code>0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B</code></td><td>v1.3.0</td><td>eip155</td></tr><tr><td><code>0x9641d764fc13c8B624c04430C7356C1C7C8102e2</code></td><td>v1.4.1</td><td>canonical</td></tr></tbody></table>

See [safe-deployments](https://github.com/safe-global/safe-deployments/tree/main/src/assets) for more information.

## **Security Considerations**

* Delegatecalls can modify Safe state if not properly restricted. Owners should NOT approve delegatecall targets that enable the following:
  * Directly modifying any of the Safe's state, including the Safe's nonce.
  * Additional delegatecalls. For example, the [MultiSend.sol](https://github.com/safe-global/safe-smart-account/blob/v1.4.1-3/contracts/libraries/MultiSend.sol) library that is _not_ "call only" should not be approved. The [MultiSendCallOnly.sol](https://github.com/safe-global/safe-smart-account/blob/v1.4.1-3/contracts/libraries/MultiSendCallOnly.sol) is approved by default.
* HSG validates that approved delegatecalls don't modify critical Safe parameters, but relies on the Safe' nonce to do so.
* Direct calls to the Safe are always prohibited
* When detaching HSG from a Safe â€” i.e. when calling `detach()` â€” the owner must trust that admin(s) of the signer Hat(s) will not front-run the detachment to add arbitrary signers. Since admins in Hats Protocol are already trusted (and can be revoked, held accountable, etc.) this is not an additional risk, but HSG owners should nonetheless be aware of this risk.

## Contract Ownership

The wearer of the `ownerHat` can make the following changes to Hats Signer Gate:

1. "Transfer" ownership to a new Hat by changing the `ownerHat`
2. Change the threshold configuration
3. Enable other Zodiac modules on HSG itself
4. Enable another Zodiac guard on HSG itself
5. Add other Hats as valid signer Hats
6. Enable or disable the ability for others to claim signer rights on behalf of valid hat wearers (`claimableFor`)
7. Detach HatsSignerGate from the Safe (removing it as both guard and module)
8. Migrate to a new HatsSignerGate instance
9. Enable or disable specific delegatecall targets
10. Lock the contract permanently, preventing any further owner changes

## Deploying New Instances

Instances of HSG can be created via the [Zodiac module proxy factory](https://github.com/gnosisguild/zodiac/blob/18b7575bb342424537883f7ebe0a94cd7f3ec4f6/contracts/factory/ModuleProxyFactory.sol).

Instances can be created for an existing Safe by passing the Safe address on initialization, or for a new Safe to be deployed from within HSG's initialization.

### Security Audits

v2 â€” the present version â€” has received the following security audits. See the v2 audits directory for the detailed reports.

| Auditor  | Report Date       | Commit Hash                                                                                             | Notes                     |
| -------- | ----------------- | ------------------------------------------------------------------------------------------------------- | ------------------------- |
| Sherlock | December 13, 2024 | [a9e3f4f](https://github.com/Hats-Protocol/hats-zodiac/commit/a9e3f4f0e968fb332800a468eddcb993fc6d5cd2) | 166 auditors participated |

{% hint style="info" %}
Since this audit was completed, HSG code was updated to add a variable salt to the Safe proxy creation within the `SafeManagerLib.deploySafeAndAttachHSG` function. This ensures that the address of the Safe proxy is unique to the HSG instance.
{% endhint %}

## Recent Deployments

See [Releases](https://github.com/Hats-Protocol/hats-zodiac/releases) for deployments. Specific deployment parameters are stored here.

# ðŸ‘’ Hats Signer Gate SDK

{% hint style="warning" %}
This SDK currently uses Hats Signer Gate v1. There is a new version, [Hats Signer Gate v2](../hats-signer-gate-v2.md), which should be used instead. The docs for this SDK will be updated and this note will be removed once this SDK has been updated to work with v2.
{% endhint %}

## Overview

Hats Signer Gate (HSG) is a contract that grants multisig signing rights to addresses wearing a given Hat, enabling on-chain organizations (such as DAOs) to revocably delegate constrained signing authority and responsibility to individuals.

Multi Hats Signer Gate (MHSG) is a modification of HSG that supports setting multiple Hats as valid signer Hats.

The SDK is an open source JavaScript client for creating and interacting with HSG and/or MHSG instances and was designed to work both in the browser and in Node.js.

For an in-depth overview of Hats Signer Gate, click [here](../../hats-integrations/permissions-and-authorities/safe-multisig-signing-authority.md).

{% content-ref url="getting-started.md" %}
[getting-started.md](getting-started.md)
{% endcontent-ref %}

{% content-ref url="creating-new-instances.md" %}
[creating-new-instances.md](creating-new-instances.md)
{% endcontent-ref %}

{% content-ref url="hats-signer-gate.md" %}
[hats-signer-gate.md](hats-signer-gate.md)
{% endcontent-ref %}

{% content-ref url="multi-hats-signer-gate.md" %}
[multi-hats-signer-gate.md](multi-hats-signer-gate.md)
{% endcontent-ref %}

{% content-ref url="hsg-and-mhsg-handlers.md" %}
[hsg-and-mhsg-handlers.md](hsg-and-mhsg-handlers.md)
{% endcontent-ref %}

# Getting Started

### _Install_

yarn:

```bash
yarn add @hatsprotocol/hsg-sdk viem
```

npm:

```bash
npm install @hatsprotocol/hsg-sdk viem
```

The SDK uses Viem in order to interact with the various chains and includes it as a peer dependency.

### _HatsSignerGateClient Initialization_

Import and initialize _HatsSignerGateClient_:

```typescript
import { HatsSignerGateClient } from "@hatsprotocol/hsg-sdk";

const hatsSignerGateClient = new HatsSignerGateClient({
    publicClient,
    walletClient,
});
```

_**Arguments**_:

```typescript
{
    publicClient: PublicClient;
    walletClient: WalletClient;
}
```

* `publicClient` - A Viem Public Client, used for onchain read operations.
* `walletClient` - A Viem Wallet Client, used for onchain write operations.&#x20;

# Creating New Instances

Create new Instances of Hats Signer Gate (HSG) and/or Multi Hats Signer Gate (MHSG), optionally together with a new Safe, using the [Hats Signer Gate Factory](https://github.com/Hats-Protocol/hats-zodiac/blob/main/src/HatsSignerGateFactory.sol).&#x20;

## deployHatsSignerGateAndSafe

Create a new HSG and a new Safe, all wired up together.

```typescript
const createHsgResult = await hatsSignerGateClient.deployHatsSignerGateAndSafe({
    account,
    ownerHatId,
    signersHatId,
    minThreshold,
    targetThreshold,
    maxSigners,
});
```

_**Arguments**_:

```typescript
{
    account: Account | Address;
    ownerHatId: bigint;
    signersHatId: bigint;
    minThreshold: bigint;
    targetThreshold: bigint;
    maxSigners: bigint;
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `ownerHatId` - ID of the HSG's Owner Hat.
* `signersHatId` - ID of the HSG's Signers Hat.
* `minThreshold` - HSG's min threshold.
* `targetThreshold` - HSG's target threshold.
* `maxSigners` - HSG's max amount of signers.

_**Response**_:

```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
  newHsgInstance: `0x${string}`;
  newSafeInstance: `0x${string}`;
}
```

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.
* `newHsgInstance` - In case of success, the address of the new HSG instance.
* newSafeInstance - In case of success, the address of the new Safe instance.

## deployHatsSignerGate

Deploy a new HSG and relate it to an existing Safe. In order to wire it up to the existing Safe, the owners of the Safe must enable it as a module and guard.

* WARNING: HatsSignerGate must not be attached to a Safe with any other modules.
* WARNING: HatsSignerGate must not be attached to its Safe if `validSignerCount() >= _maxSigners`

Before wiring up HatsSignerGate to its Safe, call `canAttachHSGToSafe` and make sure the result is `true`. Failure to do so may result in the Safe being locked forever.

```typescript
const createHsgResult = await hatsSignerGateClient.deployHatsSignerGate({
    account,
    ownerHatId,
    signersHatId,
    safe,
    minThreshold,
    targetThreshold,
    maxSigners,
});
```

_**Arguments**_:

```typescript
{
    account: Account | Address;
    ownerHatId: bigint;
    signersHatId: bigint;
    safe: Address;
    minThreshold: bigint;
    targetThreshold: bigint;
    maxSigners: bigint;
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `ownerHatId` - ID of the HSG's Owner Hat.
* `signersHatId` - ID of the HSG's Signers Hat.
* `safe` - Existing Gnosis Safe that the signers will join.
* `minThreshold` - HSG's min threshold.
* `targetThreshold` - HSG's target threshold.
* `maxSigners` - HSG's max amount of signers.

_**Response**_:

```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
  newHsgInstance: `0x${string}`;
}
```

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.
* `newHsgInstance` - In case of success, the address of the new HSG instance.

## deployMultiHatsSignerGateAndSafe

Create a new MHSG and a new Safe, all wired up together.

```typescript
const createMhsgResult = await hatsSignerGateClient.deployMultiHatsSignerGateAndSafe({
    account,
    ownerHatId,
    signersHatIds,
    minThreshold,
    targetThreshold,
    maxSigners,
});
```

_**Arguments**_:

```typescript
{
    account: Account | Address;
    ownerHatId: bigint;
    signersHatIds: bigint[];
    minThreshold: bigint;
    targetThreshold: bigint;
    maxSigners: bigint;
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `ownerHatId` - ID of the MHSG's Owner Hat.
* `signersHatIds` - IDs of the MHSG's Signers Hats.
* `minThreshold` - MHSG's min threshold.
* `targetThreshold` - MHSG's target threshold.
* `maxSigners` - MHSG's max amount of signers.

_**Response**_:

```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
  newMultiHsgInstance: `0x${string}`;
  newSafeInstance: `0x${string}`;
}
```

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.
* `newMultiHsgInstance` - In case of success, the address of the new MHSG instance.
* newSafeInstance - In case of success, the address of the new Safe instance.

### deployMultiHatsSignerGate

Deploy a new MHSG and relate it to an existing Safe. In order to wire it up to the existing Safe, the owners of the Safe must enable it as a module and guard.

* WARNING: MultiHatsSignerGate must not be attached to a Safe with any other modules.
* WARNING: MultiHatsSignerGate must not be attached to its Safe if `validSignerCount()` >= `_maxSigners`

Before wiring up MultiHatsSignerGate to its Safe, call `canAttachMHSGToSafe` and make sure the result is `true`. Failure to do so may result in the Safe being locked forever.

```typescript
const createMhsgResult = await hatsSignerGateClient.deployMultiHatsSignerGate({
    account,
    ownerHatId,
    signersHatIds,
    safe,
    minThreshold,
    targetThreshold,
    maxSigners,
});
```

_**Arguments**_:

```typescript
{
    account: Account | Address;
    ownerHatId: bigint;
    signersHatIds: bigint[];
    safe: Address;
    minThreshold: bigint;
    targetThreshold: bigint;
    maxSigners: bigint;
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `ownerHatId` - ID of the MHSG's Owner Hat.
* `signersHatIds` - IDs of the MHSG's Signers Hats.
* `safe` - Existing Gnosis Safe that the signers will join.
* `minThreshold` - MHSG's min threshold.
* `targetThreshold` - MHSG's target threshold.
* `maxSigners` - MHSG's max amount of signers.

_**Response**_:

```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
  newMultiHsgInstance: `0x${string}`;
}
```

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.
* `newMultiHsgInstance` - In case of success, the address of the new MHSG instance.

# Hats Signer Gate

Interact with [HSG](https://github.com/Hats-Protocol/hats-zodiac/blob/main/src/HatsSignerGate.sol) instances.

## Signers Management

## hsgClaimSigner

Claim signer rights on the safe.&#x20;

In order to successfully claim:

* The calling account must wear the [Signers Hat](hats-signer-gate.md#hsgsignershatid). Use [this](hats-signer-gate.md#hsgisvalidsigner) function is order to check whether an account is a valid signer.
* Caller must not be already a signer.
* The current amount of valid signers should be smaller than the configured amount of maximum signers.

```typescript
const claimSignerResult = await hatsSignerGateClient.hsgClaimSigner({
    account,
    hsgInstance,
});
```

_**Arguments**_:

```typescript
{
    account: Account | Address;
    hsgInstance: Address;
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `hsgInstance` - HSG's instance address.

_**Response**_:

```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
}
```

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.

### hsgIsValidSigner

Check if an account is wearing the Signers Hat (regardless whether the account has claimed signer rights or not).

<pre class="language-typescript"><code class="lang-typescript">const isValid = await hatsSignerGateClient.hsgIsValidSigner({
<strong>    hsgInstance,
</strong><strong>    address
</strong>});
</code></pre>

_**Arguments**_:

```typescript
{
    hsgInstance: Address;
    address: Address;
}
```

* `hsgInstance` - HSG's instance address.
* `address` -The address to check.

_**Response**_:

```typescript
boolean
```

`true` if valid, `false` otherwise.

## claimedAndStillValid

Check if an account has claimed signer rights and is still valid.

<pre class="language-typescript"><code class="lang-typescript">const claimedAndValid = await hatsSignerGateClient.claimedAndStillValid({
<strong>    instance,
</strong><strong>    address    
</strong>});
</code></pre>

_**Arguments**_:

```typescript
{
    instance: Address;
    address: Address;
}
```

* `instance` - HSG's instance address.
* `address` -The address to check.

_**Response**_:

```typescript
boolean
```

`true` if the account is one of the safe's owners and is still valid, `false` otherwise.

## validSignerCount

Tallies the number of existing Safe owners that wear the Signers Hat.

<pre class="language-typescript"><code class="lang-typescript">const count = await hatsSignerGateClient.validSignerCount({
<strong>    instance 
</strong>});
</code></pre>

_**Arguments**_:

```typescript
{
    instance: Address;
}
```

* `instance` - HSG's instance address.

_**Response**_:

```typescript
bigint
```

The number of valid signers on the Safe.

## reconcileSignerCount

Tallies the number of existing Safe owners that wear a Signers Hat and updates the Safe's threshold if necessary. Does NOT remove invalid Safe owners.

```typescript
const res = await hatsSignerGateClient.reconcileSignerCount({
    account,
    instance,
});
```

_**Arguments**_:

```typescript
{
    account: Account | Address;
    instance: Address;
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `instance` - HSG's instance address.

_**Response**_:

```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
}
```

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.

## removeSigner

Removes an invalid signer from the Safe, updating its threshold if appropriate.

```typescript
const res = await hatsSignerGateClient.removeSigner({
    account,
    instance,
    signer,
});
```

_**Arguments**_:

```typescript
{
    account: Account | Address;
    instance: Address;
    signer: Address;
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `instance` - HSG's instance address.
* `signer` - The address to remove if not a valid signer.

_**Response**_:

```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
}
```

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.

## HSG Instance Properties

Getters for the basic properties of a HSG instance.

### hsgSignersHatId

Get a HSG's Signers Hat ID.

<pre class="language-typescript"><code class="lang-typescript">const signersHat = await hatsSignerGateClient.hsgSignersHatId({
<strong>    hsgInstance
</strong>});
</code></pre>

_**Arguments**_:

```typescript
{
    hsgInstance: Address;
}
```

* `hsgInstance` - HSG's instance address.

_**Response**_:

```typescript
bigint
```

HSG's Signers Hat ID.

## getSafe

Get a HSG's attached Safe.

<pre class="language-typescript"><code class="lang-typescript">const safe = await hatsSignerGateClient.getSafe({
<strong>    instance 
</strong>});
</code></pre>

_**Arguments**_:

```typescript
{
    instance: Address;
}
```

* `instance` - HSG's instance address.

_**Response**_:

```typescript
Address
```

Address of the attached Safe.

### getMinThreshold

Get a HSG's minimum threshold.

<pre class="language-typescript"><code class="lang-typescript">const minThreshold = await hatsSignerGateClient.getMinThresholde({
<strong>    instance
</strong>});
</code></pre>

_**Arguments**_:

```typescript
{
    instance: Address;
}
```

* `instance` - HSG's instance address.

_**Response**_:

```typescript
bigint
```

The instance's min threshold.

### getTargetThreshold

Get a HSG's target threshold.

<pre class="language-typescript"><code class="lang-typescript">const targetThreshold = await hatsSignerGateClient.getTargetThreshold({
<strong>    instance
</strong>});
</code></pre>

_**Arguments**_:

```typescript
{
    instance: Address;
}
```

* `instance` - HSG's instance address.

_**Response**_:

```typescript
bigint
```

The instance's target threshold.

### getMaxSigners

Get a HSG's maximum amount of signers.

<pre class="language-typescript"><code class="lang-typescript">const maxSigners = await hatsSignerGateClient.getMaxSigners({
<strong>    instance
</strong>});
</code></pre>

_**Arguments**_:

```typescript
{
    instance: Address;
}
```

* `instance` - HSG's instance address.

_**Response**_:

```typescript
bigint
```

The instance's max signers.

### getOwnerHat

Get a HSG's Owner Hat.

<pre class="language-typescript"><code class="lang-typescript">const ownerHat = await hatsSignerGateClient.getOwnerHat({
<strong>    instance 
</strong>});
</code></pre>

_**Arguments**_:

```typescript
{
    instance: Address;
}
```

* `instance` - HSG's instance address.

_**Response**_:

```typescript
bigint
```

The instance's Owner Hat.

## HSG Owner

Following functions are only authorized to the wearer(s) of the HSG instance's Owner Hat.

### setTargetThreshold

Sets a new target threshold, and changes Safe's threshold if appropriate.&#x20;

In order to successfully execute the function:

* The caller must be a wearer of the HSG's Owner Hat.
* The new target threshold should not be smaller than the minimum threshold.
* The new target threshold should not be larger than the maximum amount of signers.

```typescript
const res = await hatsSignerGateClient.setTargetThreshold({
    account,
    instance,
    targetThreshold,
});
```

_**Arguments**_:

```typescript
{
    account: Account | Address;
    instance: Address;
    targetThreshold: bigint;
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `instance` - HSG's instance address.
* `targetThreshold` - The new target threshold to set.

_**Response**_:

```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
}
```

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.

### setMinThreshold

Sets a new minimum threshold.

In order to successfully execute the function:

* The caller must be a wearer of the HSG's Owner Hat.
* The new minimum threshold should not be larger than the target threshold.
* The new minimum threshold should not be larger than the maximum amount of signers.

```typescript
const res = await hatsSignerGateClient.setMinThreshold({
    account,
    instance,
    minThreshold,
});
```

_**Arguments**_:

```typescript
{
    account: Account | Address;
    instance: Address;
    minThreshold: bigint;
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `instance` - HSG's instance address.
* `minThreshold` - The new minimum threshold to set.

_**Response**_:

```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
}
```

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.

### setOwnerHat

Sets a new Owner Hat.

In order to successfully execute the function:

* The caller must be a wearer of the current Owner Hat.

```typescript
const res = await hatsSignerGateClient.setOwnerHat({
    account,
    instance,
    newOwnerHat,
    hatsContractAddress,
});
```

_**Arguments**_:

```typescript
{
    account: Account | Address;
    instance: Address;
    newOwnerHat: bigint;
    hatsContractAddress: Address;
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `instance` - HSG's instance address.
* `newOwnerHat` - The new Owner Hat to set.
* `hatsContractAddress` - The Hats.sol contract address of the new Owner Hat.

_**Response**_:

```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
}
```

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.

# Multi Hats Signer Gate

Interact with [MHSG](https://github.com/Hats-Protocol/hats-zodiac/blob/main/src/MultiHatsSignerGate.sol) instances.

## Signers Management

### mhsgClaimSigner

Claim signer rights on the safe.&#x20;

In order to successfully claim:

* The provided `hatId` parameter should be a [valid Signers Hat ](multi-hats-signer-gate.md#mhsgisvalidsignershat)and the caller is one of its [wearers](multi-hats-signer-gate.md#mhsgisvalidsigner).
* Caller must not be already a signer.
* The current amount of valid signers should be smaller than the configured amount of maximum signers.

```typescript
const claimSignerResult = await hatsSignerGateClient.mhsgClaimSigner({
    account,
    mhsgInstance,
    hatId,
});
```

_**Arguments**_:

```typescript
{
    account: Account | Address;
    mhsgInstance: Address;
    hatId: bigint;
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `mhsgInstance` - MHSG's instance address.
* `hatId` - The hat ID to claim signer rights for, must be a valid Signers Hat.

_**Response**_:

```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
}
```

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.

### mhsgIsValidSigner

Check if an account is wearing one of the Signers Hats and also claimed signer rights for it.

<pre class="language-typescript"><code class="lang-typescript">const isValid = await hatsSignerGateClient.mhsgIsValidSigner({
<strong>    mhsgInstance,
</strong><strong>    address
</strong>});
</code></pre>

_**Arguments**_:

```typescript
{
    mhsgInstance: Address;
    address: Address;
}
```

* `mhsgInstance` - MHSG's instance address.
* `address` -The address to check.

_**Response**_:

```typescript
boolean
```

`true` if valid, `false` otherwise.

### claimedAndStillValid

Check if an account has claimed signer rights and is still valid.

<pre class="language-typescript"><code class="lang-typescript">const claimedAndValid = await hatsSignerGateClient.claimedAndStillValid({
<strong>    instance,
</strong><strong>    address
</strong>});
</code></pre>

_**Arguments**_:

```typescript
{
    instance: Address;
    address: Address;
}
```

* `instance` - HSG's instance address.
* `address` -The address to check.

_**Response**_:

```typescript
boolean
```

`true` if the account is one of the safe's owners and is still valid, `false` otherwise.

### validSignerCount

Tallies the number of existing Safe owners that wear the Signers Hat.

<pre class="language-typescript"><code class="lang-typescript">const count = await hatsSignerGateClient.validSignerCount({
<strong>    instance
</strong>});
</code></pre>

_**Arguments**_:

```typescript
{
    instance: Address;
}
```

* `instance` - MHSG's instance address.

_**Response**_:

```typescript
bigint
```

The number of valid signers on the Safe.

### reconcileSignerCount

Tallies the number of existing Safe owners that wear a Signers Hat and updates the Safe's threshold if necessary. Does NOT remove invalid Safe owners.

```typescript
const res = await hatsSignerGateClient.reconcileSignerCount({
    account,
    instance,
});
```

_**Arguments**_:

```typescript
{
    account: Account | Address;
    instance: Address;
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `instance` - MHSG's instance address.

_**Response**_:

```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
}
```

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.

### removeSigner

Removes an invalid signer from the Safe, updating its threshold if appropriate.

```typescript
const res = await hatsSignerGateClient.removeSigner({
    account,
    instance,
    signer,
});
```

_**Arguments**_:

```typescript
{
    account: Account | Address;
    instance: Address;
    signer: Address;
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `instance` - MHSG's instance address.
* `signer` - The address to remove if not a valid signer.

_**Response**_:

```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
}
```

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.

## MHSG Instance Properties

Getters for the basic properties of a MHSG instance.

### mhsgIsValidSignersHat

Check if a given Hat is a valid Signers Hat.

<pre class="language-typescript"><code class="lang-typescript">const isValid = await hatsSignerGateClient.mhsgIsValidSignersHat({
<strong>    mhsgInstance,
</strong><strong>    hatId
</strong>});
</code></pre>

_**Arguments**_:

```typescript
{
    mhsgInstance: Address;
    hatId: bigint;
}
```

* `mhsgInstance` - MHSG's instance address.
* `hatId` -The Hat to check.

_**Response**_:

```typescript
boolean
```

`true` if valid, `false` otherwise.

### getSafe

Get a MHSG's attached Safe

<pre class="language-typescript"><code class="lang-typescript">const safe = await hatsSignerGateClient.getSafe({
<strong>    instance
</strong>});
</code></pre>

_**Arguments**_:

```typescript
{
    instance: Address;
}
```

* `hsgInstance` - MHSG's instance address.

_**Response**_:

```typescript
Address
```

Address of the attached Safe.

### getMinThreshold

Get a MHSG's minimum threshold.

<pre class="language-typescript"><code class="lang-typescript">const minThreshold = await hatsSignerGateClient.getMinThresholde({
<strong>    instance
</strong>});
</code></pre>

_**Arguments**_:

```typescript
{
    instance: Address;
}
```

* `instance` - MHSG's instance address.

_**Response**_:

```typescript
bigint
```

The instance's min threshold.

### getTargetThreshold

Get a MHSG's target threshold.

<pre class="language-typescript"><code class="lang-typescript">const targetThreshold = await hatsSignerGateClient.getTargetThreshold({
<strong>    instance
</strong>});
</code></pre>

_**Arguments**_:

```typescript
{
    instance: Address;
}
```

* `instance` - MHSG's instance address.

_**Response**_:

```typescript
bigint
```

The instance's target threshold.

### getMaxSigners

Get a MHSG's maximum amount of signers.

<pre class="language-typescript"><code class="lang-typescript">const maxSigners = await hatsSignerGateClient.getMaxSigners({
<strong>    instance
</strong>});
</code></pre>

_**Arguments**_:

```typescript
{
    instance: Address;
}
```

* `instance` - MHSG's instance address.

_**Response**_:

```typescript
bigint
```

The instance's max signers.

### getOwnerHat

Get a MHSG's Owner Hat.

<pre class="language-typescript"><code class="lang-typescript">const ownerHat = await hatsSignerGateClient.getOwnerHat({
<strong>    instance
</strong>});
</code></pre>

_**Arguments**_:

```typescript
{
    instance: Address;
}
```

* `instance` - MHSG's instance address.

_**Response**_:

```typescript
bigint
```

The instance's Owner Hat.

## HSG Owner

Following functions are only authorized to the wearer(s) of the MHSG instance's Owner Hat.

### mhsgAddSignerHats

Add new approved Signers Hats.

In order to successfully execute the function:

* The caller must be a wearer of the MHSG's Owner Hat.

```typescript
const res = await hatsSignerGateClient.mhsgAddSignerHats({
    account,
    mhsgInstance,
    newSignerHats,
});
```

_**Arguments**_:

```typescript
{
    account: Account | Address;
    mhsgInstance: Address;
    newSignerHats: bigint[];
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `mhsgInstance` - MHSG's instance address.
* `newSignerHats` - Array of Hat IDs to add as approved Signers Hats.

_**Response**_:

```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
}
```

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.

### setTargetThreshold

Sets a new target threshold, and changes the Safe's threshold if appropriate.&#x20;

In order to successfully execute the function:

* The caller must be a wearer of the MHSG's Owner Hat.
* The new target threshold should not be smaller than the minimum threshold.
* The new target threshold should not be larger than the maximum amount of signers.

```typescript
const res = await hatsSignerGateClient.setTargetThreshold({
    account,
    instance,
    targetThreshold,
});
```

_**Arguments**_:

```typescript
{
    account: Account | Address;
    instance: Address;
    targetThreshold: bigint;
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `instance` - HSG's instance address.
* `targetThreshold` - The new target threshold to set.

_**Response**_:

```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
}
```

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.

### setMinThreshold

Sets a new minimum threshold.

In order to successfully execute the function:

* The caller must be a wearer of the MHSG's Owner Hat.
* The new minimum threshold should not be larger than the target threshold.
* The new minimum threshold should not be larger than the maximum amount of signers.

```typescript
const res = await hatsSignerGateClient.setMinThreshold({
    account,
    instance,
    minThreshold,
});
```

_**Arguments**_:

```typescript
{
    account: Account | Address;
    instance: Address;
    minThreshold: bigint;
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `instance` - HSG's instance address.
* `minThreshold` - The new minimum threshold to set.

_**Response**_:

```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
}
```

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.

### setOwnerHat

Sets a new Owner Hat.

In order to successfully execute the function:

* The caller must be a wearer of the current Owner Hat.

```typescript
const res = await hatsSignerGateClient.setOwnerHat({
    account,
    instance,
    newOwnerHat,
    hatsContractAddress,
});
```

_**Arguments**_:

```typescript
{
    account: Account | Address;
    instance: Address;
    newOwnerHat: bigint;
    hatsContractAddress: Address;
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `instance` - MHSG's instance address.
* newOwnerHat - The new Owner Hat to set.
* `hatsContractAddress` - The Hats.sol contract address of the new Owner Hat.

_**Response**_:

```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
}
```

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.

# HSG & MHSG Handlers

The following section describes a different way of interacting with HSG and MHSG instances, than documented in the previous sections. In particular, in the previous sections, for each operation on the [HSG](hats-signer-gate.md) and [MHSG](multi-hats-signer-gate.md) contracts, there's a matching function in the SDK. &#x20;

In addition to these individual functions, the SDK also includes a single handler for calling the write operations of both HSG and MHSG instances. This enables HSG/MHSG interactions to be optionally handled in a similar way to [Hats Modules interactions](../hats-modules/modules-sdk/interact-with-instances.md#callinstancewritefunction), by working with the HSG and MHSG [metadata objects](hsg-and-mhsg-handlers.md#metadata) and the single write functions [handler](hsg-and-mhsg-handlers.md#handler).

## Handlers

### callInstanceWriteFunction

Call a HSG/MHSG instance's write function.

```typescript
const res = await hatsSignerGateClient.callInstanceWriteFunction({
    account,
    type,
    instance,
    func,
    args,
});
```

_**Arguments**_:

```typescript
{
    account: Account | Address;
    type: HsgType;
    instance: Address;
    func: WriteFunction;
    args: unknown[];
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `type` - 'HSG' or 'MHSG'.
* `instance` - The MHSG/HSG instance address.
* `func` - The write function to call, provided as an object of type [WriteFunction](hsg-and-mhsg-handlers.md#writefunction).
* `args` - The arguments with which to call the function, as objects of type [WriteFunctionArg](hsg-and-mhsg-handlers.md#writefunctionarg).

_**Response**_:

```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
}
```

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.

### getInstanceParameters

Get a HSG or MHSG instance live parameters:

* Safe address
* Min threshold
* Target threshold
* Max signers
* Owner Hat

```typescript
const params = await hatsSignerGateClient.getInstanceParameters(instance);
```

_**Arguments**_:

```typescript
instance: `0x${string}`
```

`instance` - Instance's address.

_**Response**_:

```typescript
{
  label: string;
  value: unknown;
  solidityType: string;
  displayType: string;
}[]
```

An array of objects, each containing a parameter's information:

* `label` - The parameter's name/description.
* `value` - The parameter's value, as was returned from the instance contract.
* `solidityType` - The parameter's Solidity type.
* `displayType`- The parameter's display type. Its purpose is for UIs to be able to render an appropriate component for the parameter

## Metadata

Both the HSG and MHSG metadata objects include their ABIs, all their [write functions](hsg-and-mhsg-handlers.md#writefunction) together with the metadata of each function and the [custom roles](hsg-and-mhsg-handlers.md#role) that are associated with them.&#x20;

### getMetadata

Get the metadata object of HSG or MHSG.

```typescript
const metadata = await hatsSignerGateClient.getMetadata(type);
```

_**Arguments**_:

```typescript
HsgType
```

"HSG" or "MHSG"

_**Response**_:

```typescript
HsgMetadata
```

An object of type [HsgMetadata](hsg-and-mhsg-handlers.md#hsgmetadata).

## Types

### HsgMetadata

Represents a HSG or MHSG metadata object.

```typescript
{
  customRoles: Role[]; // HSG/MHSG custom roles
  writeFunctions: WriteFunction[]; // HSG/MHSG write functions
  abi: Abi; // HSG/MHSG ABI
}
```

### Role

A  custom HSG/MHSG role. Each role is associated with a hat and grants permissions to the hat's wearer(s) to call certain functions on the contract.

There are two special roles with a reserved ID:

1. `public` role, associated with functions that are permitted to any caller.
2. `hatAdmins` role, associated with functions that are permitted to the target hat's admins.

```typescript
{
  id: string; // role's ID
  name: string; // role's name
  criteria: string; // The name of the contract function which can be used to retrieve the role's hat
  hatAdminsFallback?: boolean; // 'true' indicates that the role is granted to the target hat's admin(s) if/when the role's criteria function returns zero.
}
```

### WriteFunction

The HSG/MHSG write functions. Each write function is associated with a role that grants permissions to the role's wearer(s) to call the function on the contract.

```typescript
{
  roles: string[]; // IDs of the roles that have the authority to call the function
  functionName: string; // the name of the function in the contract
  label: string; // the name to be displayed to end users
  description: string; // a description of the function to be displayed to end users
  primary?: boolean; // 'true' indicates that this function is the primary function of the roles it is associated with. Front ends can use this information to display the function more prominently for each role
  args: WriteFunctionArg[]; // the arguments of the function
}
```

### >WriteFunctionArg

HSG/MHSG write function argument.

```typescript
{
  name: string; // arg's name
  description: string; // arg's description
  type: string; // arg's solidity type, e.g. 'uint256'
  displayType: string; // a free-text field that tells front ends how to generate a proper UI component for the parameter
  optional?: boolean; // setting to 'true' indicates that this input is optional
}
```
# 1 of N Hats Account

HatsAccount1ofN is a flavor of HatsAccount that mirrors the typical 1-of-n security model of hat-based role and permission management. Any single wearer of a HatsAccount1ofN instance's hat has full control over that HatsAccount. If a hat has multiple wearers, they each individually have full control.

# Getting Started

## _Install_

yarn:

```bash
yarn add @hatsprotocol/hats-account-sdk viem
```

npm:

```bash
npm install @hatsprotocol/hats-account-sdk viem
```

The SDK uses Viem in order to interact with the various chains and includes it as a peer dependency.

## _HatsAccount1ofNClient Initialization_

Import and initialize _HatsAccount1ofNClient_:

```typescript
import { HatsAccount1ofNClient } from "@hatsprotocol/hats-account-sdk";

const hatsAccount1ofNClient = new HatsAccount1ofNClient({
    publicClient,
    walletClient,
});
```

_**Arguments**_:

```typescript
{
    publicClient: PublicClient;
    walletClient: WalletClient;
}
```

* `publicClient` - A Viem Public Client, used for onchain read operations.
* `walletClient` - A Viem Wallet Client, used for onchain write operations.&#x20;

# Creating New Instances

Create new Instances of a 1 of N Hats Account, and/or predict the addresses of accounts.

## createAccount

Create a new 1 of N Hats Account instance.

```typescript
const createHatsAccountResult = await hatsAccount1ofNClient.createAccount({
    account,
    hatId,
    salt,
});
```

_**Arguments**_:

```typescript
{
    account: Account | Address;
    hatId: bigint;
    salt: bigint;
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `hatId` - ID of the hat for which to create the account.
* `signersHatId` - arbitrary number as "salt".

_**Response**_:

```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
  newAccount: `0x${string}`;
}
```

An object of type [CreateAccountResult](types.md#createaccountresult), includes:

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.
* `newAccount` - In case of success, the address of the new account.

## predictAccountAddress

Predict the address of a 1 of N Hats Account instance.

```typescript
const predictedAccount = await hatsAccount1ofNClient.predictAccountAddress({
    hatId,
    salt,
});
```

_**Arguments**_:

```typescript
{
    hatId: bigint;
    salt: bigint;
}
```

* `hatId` - ID of the hat for which to create the account.
* `signersHatId` - arbitrary number as "salt".

_**Response**_:

```typescript
`0x${string}`
```

The predicted account address.

# Executing From An Instance

Execute operations from a Hats Account instance. Only wearers of the instance's hat can call the following functions.

## execute

Execute an operation.

```typescript
const executionResult = await hatsAccount1ofNClient.execute({
    account,
    instance,
    operation,
});
```

_**Arguments**_:

```typescript
{
    account: Account | Address;
    instance: Address;
    operation: Operation;
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `instance` - The Hats Account instance.
* `operation` - An object of type [Operation](types.md#operation), which includes the operation's execution data.

_**Response**_:

```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
}
```

An object of type [ExecutionResult](types.md#executionresult), includes:

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.

## executeBatch

Execute a batch of operations.

```typescript
const executionResult = await hatsAccount1ofNClient.executeBatch({
    account,
    instance,
    operations,
});
```

_**Arguments**_:

```typescript
{
    account: Account | Address;
    instance: Address;
    operations: Operation[];
}
```

* `account` - Viem account (Address for JSON-RPC accounts or Account for other types).
* `instance` - The Hats Account instance.
* `operations` - An array of  [Operation](types.md#operation) objects, each includes an operation's execution data.

_**Response**_:

```typescript
{
  status: "success" | "reverted";
  transactionHash: `0x${string}`;
}
```

An object of type [ExecutionResult](types.md#executionresult), includes:

* `status` - "success" if transaction was successful, "reverted" if transaction reverted.
* `transactionHash` - transaction's hash.

# Constants

Following constant values are exported:

<pre class="language-typescript"><code class="lang-typescript"><strong>import {
</strong>  HATS_ACCOUNT_1OFN_ABI, // Hats Account 1 of N ABI
  ERC6551_REGISTRY_ABI, // The registry's ABI (factory which deploys Hats Account instances)
  HATS_ACCOUNT_1OFN_IMPLEMENTATION, // Mapping between a chain ID to the Hats Account 1 of N implementation address in this chain
  ERC6551_REGISTRY, // The registry's address
<strong>} from "@hatsprotocol/hats-account-sdk";
</strong></code></pre>

# Types

## Operation

Execution data for a Hats Account operation.

```typescript
{
  to: Address;
  value: bigint;
  data: Hex;
  operation: OperationType;
}
```

* to - The target address of the operation.
* value - The Ether value to be sent to the target.
* data - The encoded operation calldata.
* operation - A value of type [OperationType](types.md#operationtype), indicating the type of operation to perform (call or delegate-call).

## OperationType

Enum describing the operation to execute.

```typescript
enum OperationType {
  Call,
  DelegateCall,
}
```

## CreateAccountResult

Account creation result.

```typescript
enum OperationType {
  status: "success" | "reverted";
  transactionHash: Address;
  newAccount: Address;
}
```

## ExecutionResult

Hats Account execution result.

```typescript
enum OperationType {
  status: "success" | "reverted";
  transactionHash: Address;
}
```

# ðŸŒ Hats Security Audits

Both [Hats Protocol v1](https://github.com/Hats-Protocol/hats-protocol) and [Hats Signer Gate](https://github.com/Hats-Protocol/hats-zodiac#security-audits) have received two security audits, listed below. See the [audits](https://github.com/Hats-Protocol/hats-protocol/tree/main/audits) directory for the detailed reports.&#x20;

| Auditor        | Report Date  | Review Commit Hash                                                                                        |
| -------------- | ------------ | --------------------------------------------------------------------------------------------------------- |
| Trust Security | Feb 23, 2023 | [60f07df](https://github.com/Hats-Protocol/hats-protocol/commit/60f07df0679ba52d4ad818b1bb3700d2f4f5a63a) |
| Sherlock       | May 3, 2023  | [fafcfd](https://github.com/Hats-Protocol/hats-protocol/commit/fafcfdf046c0369c1f9e077eacd94a328f9d7af0)  |

